/**
 * ğŸ¤– MarFaNet Telegram Management Routes
 * SHERLOCK v32.0: Advanced Telegram Bot Integration with AI-powered message parsing
 * 
 * Features:
 * - Employee management and authentication
 * - Message parsing and command handling
 * - Task generation and management
 * - Leave request processing
 * - Technical report handling
 * - Daily report management
 */

import { Express } from 'express';
import { db } from '../db';
import { 
  employees, 
  employeeTasks, 
  telegramGroups, 
  telegramMessages, 
  leaveRequests, 
  technicalReports, 
  dailyReports,
  insertEmployeeSchema,
  insertEmployeeTaskSchema,
  insertTelegramGroupSchema,
  insertTelegramMessageSchema,
  insertLeaveRequestSchema,
  insertTechnicalReportSchema,
  insertDailyReportSchema
} from '../../shared/schema';
import { eq, desc, and } from 'drizzle-orm';
import { z } from 'zod';
import { EnhancedTelegramService, MessageParser, EntityExtractor, CommandHandler } from '../services/enhanced-telegram-service';

let telegramService: EnhancedTelegramService | null = null;

// ==================== VALIDATION SCHEMAS ====================

const webhookUpdateSchema = z.object({
  update_id: z.number(),
  message: z.object({
    message_id: z.number(),
    from: z.object({
      id: z.number(),
      is_bot: z.boolean(),
      first_name: z.string(),
      last_name: z.string().optional(),
      username: z.string().optional()
    }),
    chat: z.object({
      id: z.number(),
      title: z.string().optional(),
      type: z.enum(['private', 'group', 'supergroup', 'channel'])
    }),
    date: z.number(),
    text: z.string().optional()
  }).optional(),
  edited_message: z.object({}).optional(),
  callback_query: z.object({}).optional()
});

const configSchema = z.object({
  token: z.string().min(1),
  webhook_url: z.string().url().optional(),
  use_polling: z.boolean().default(false),
  polling_timeout: z.number().default(60)
});

// ==================== TELEGRAM ROUTES ====================

export function registerTelegramRoutes(app: Express, authMiddleware: any) {

  // ==================== BOT CONFIGURATION ====================

  // Direct Test Messages for Employee Groups
  app.post('/api/telegram/test-employee-groups', authMiddleware, async (req, res) => {
    try {
      const { groupType } = req.body as { groupType: string };

      // Test message formats for different employee subgroups
      const testMessages: Record<string, { persian: string; english: string }> = {
        'daily-report': {
          persian: '#Ú¯Ø²Ø§Ø±Ø´_Ø±ÙˆØ²Ø§Ù†Ù‡\nğŸ“… ØªØ§Ø±ÛŒØ®: Û±Û´Û°Û³/Û±Û²/Û±Û±\nğŸ‘¤ Ù†Ø§Ù…: Ø§Ø­Ù…Ø¯ Ù…Ø­Ù…Ø¯ÛŒ\nğŸ¢ Ù¾Ø±ÙˆÚ˜Ù‡: Ø·Ø±Ø§Ø­ÛŒ ÙˆØ¨â€ŒØ³Ø§ÛŒØª\nâ° Ø³Ø§Ø¹Ø§Øª Ú©Ø§Ø±: Û¸ Ø³Ø§Ø¹Øª\nâœ… Ú©Ø§Ø±Ù‡Ø§ÛŒ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡:\n- Ø·Ø±Ø§Ø­ÛŒ ØµÙØ­Ù‡ Ø§ØµÙ„ÛŒ\n- Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ CSS\n- ØªØ³Øª ÙˆØ§Ú©Ù†Ø´â€ŒÚ¯Ø±Ø§ÛŒÛŒ\nğŸ¯ Ø¨Ø±Ù†Ø§Ù…Ù‡ ÙØ±Ø¯Ø§:\n- Ú©Ø¯Ù†ÙˆÛŒØ³ÛŒ Ø¨Ø®Ø´ Ù¾Ù†Ù„ Ú©Ø§Ø±Ø¨Ø±ÛŒ\nğŸ’¬ ØªÙˆØ¶ÛŒØ­Ø§Øª: Ù¾ÛŒØ´Ø±ÙØª Ø®ÙˆØ¨ÛŒ Ø¯Ø§Ø´ØªÛŒÙ…',
          english: '#daily_report\nğŸ“… Date: 2025-03-02\nğŸ‘¤ Name: Ahmad Mohammadi\nğŸ¢ Project: Website Design\nâ° Hours: 8h\nâœ… Completed:\n- Homepage design\n- CSS optimization\n- Responsiveness testing\nğŸ¯ Tomorrow:\n- User panel coding\nğŸ’¬ Notes: Good progress made'
        },
        'task-assignment': {
          persian: '#ÙˆØ¸ÛŒÙÙ‡_Ø¬Ø¯ÛŒØ¯\nğŸ“‹ Ø¹Ù†ÙˆØ§Ù†: Ø¨Ø±Ø±Ø³ÛŒ Ø§Ù…Ù†ÛŒØª Ø³ÛŒØ³ØªÙ…\nğŸ‘¤ Ù…Ø³Ø¦ÙˆÙ„: Ù…Ø±ÛŒÙ… Ø§Ø­Ù…Ø¯ÛŒ\nğŸ“… Ø¯Ø¯Ù„Ø§ÛŒÙ†: Û±Û´Û°Û³/Û±Û²/Û±Ûµ\nğŸ¯ Ø§ÙˆÙ„ÙˆÛŒØª: Ø¨Ø§Ù„Ø§\nğŸ“ Ø´Ø±Ø­ Ú©Ø§Ø±:\n- Ø¨Ø±Ø±Ø³ÛŒ Ø¢Ø³ÛŒØ¨â€ŒÙ¾Ø°ÛŒØ±ÛŒâ€ŒÙ‡Ø§ÛŒ Ø§Ø­ØªÙ…Ø§Ù„ÛŒ\n- ØªØ³Øª Ù†ÙÙˆØ° Ø§ÙˆÙ„ÛŒÙ‡\n- Ú¯Ø²Ø§Ø±Ø´ Ù…ÙØµÙ„ Ø§Ù…Ù†ÛŒØªÛŒ\nâš ï¸ Ù†Ú©Ø§Øª Ù…Ù‡Ù…:\n- Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø¬Ø§Ø²\n- Ø±Ø¹Ø§ÛŒØª Ø­Ø±ÛŒÙ… Ø®ØµÙˆØµÛŒ',
          english: '#new_task\nğŸ“‹ Title: Security System Review\nğŸ‘¤ Assigned: Maryam Ahmadi\nğŸ“… Deadline: 2025-03-06\nğŸ¯ Priority: High\nğŸ“ Description:\n- Check vulnerabilities\n- Initial penetration testing\n- Detailed security report\nâš ï¸ Important:\n- Use authorized tools\n- Respect privacy'
        },
        'leave-request': {
          persian: '#Ù…Ø±Ø®ØµÛŒ\nğŸ‘¤ Ù†Ø§Ù…: Ø¹Ù„ÛŒ Ø±Ø¶Ø§ÛŒÛŒ\nğŸ“… Ø§Ø² ØªØ§Ø±ÛŒØ®: Û±Û´Û°Û³/Û±Û²/Û²Û°\nğŸ“… ØªØ§ ØªØ§Ø±ÛŒØ®: Û±Û´Û°Û³/Û±Û²/Û²Û²\nğŸ¥ Ù†ÙˆØ¹: Ø§Ø³ØªØ¹Ù„Ø§Ø¬ÛŒ\nğŸ“ Ø¯Ù„ÛŒÙ„: ÙˆÛŒØ²ÛŒØª Ù¾Ø²Ø´Ú©\nğŸ“ ØªÙ…Ø§Ø³ Ø§Ø¶Ø·Ø±Ø§Ø±ÛŒ: Û°Û¹Û±Û²Û³Û´ÛµÛ¶Û·Û¸Û¹\nğŸ’¼ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†: Ù…Ø­Ù…Ø¯ Ø­Ø³ÛŒÙ†ÛŒ\nâœ… Ú©Ø§Ø±Ù‡Ø§ÛŒ Ù…Ø­ÙˆÙ„ Ø´Ø¯Ù‡ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯',
          english: '#leave_request\nğŸ‘¤ Name: Ali Rezaei\nğŸ“… From: 2025-03-11\nğŸ“… To: 2025-03-13\nğŸ¥ Type: Medical\nğŸ“ Reason: Doctor visit\nğŸ“ Emergency: 09123456789\nğŸ’¼ Replacement: Mohammad Hosseini\nâœ… Assigned tasks completed'
        },
        'technical-report': {
          persian: '#Ú¯Ø²Ø§Ø±Ø´_ÙÙ†ÛŒ\nâš ï¸ Ù…Ø´Ú©Ù„: Ø®Ø±Ø§Ø¨ÛŒ Ø³Ø±ÙˆØ±\nğŸ“… Ø²Ù…Ø§Ù†: Û±Û´Û°Û³/Û±Û²/Û±Û± - Û±Û´:Û³Û°\nğŸ”§ ÙˆØ¶Ø¹ÛŒØª: Ø­Ù„ Ø´Ø¯Ù‡\nğŸ‘¤ Ú¯Ø²Ø§Ø±Ø´â€ŒØ¯Ù‡Ù†Ø¯Ù‡: Ø­Ø³ÛŒÙ† Ú©Ø±ÛŒÙ…ÛŒ\nğŸ“Š ØªØ§Ø«ÛŒØ±: Û³Û° Ø¯Ù‚ÛŒÙ‚Ù‡ Ù‚Ø·Ø¹ÛŒ Ø³Ø±ÙˆÛŒØ³\nğŸ› ï¸ Ø±Ø§Ù‡â€ŒØ­Ù„:\n- Ø±ÛŒØ³ØªØ§Ø±Øª Ø³Ø±ÙˆØ± Ø§ØµÙ„ÛŒ\n- Ø¨Ø±Ø±Ø³ÛŒ Ù„Ø§Ú¯â€ŒÙ‡Ø§\n- Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª\nğŸ”® Ù¾ÛŒØ´Ú¯ÛŒØ±ÛŒ:\n- Ù…Ø§Ù†ÛŒØªÙˆØ±ÛŒÙ†Ú¯ Ø¨ÛŒØ´ØªØ±\n- Ø¨Ú©â€ŒØ¢Ù¾ Ø®ÙˆØ¯Ú©Ø§Ø±',
          english: '#technical_report\nâš ï¸ Issue: Server failure\nğŸ“… Time: 2025-03-02 - 14:30\nğŸ”§ Status: Resolved\nğŸ‘¤ Reporter: Hossein Karimi\nğŸ“Š Impact: 30min downtime\nğŸ› ï¸ Solution:\n- Main server restart\n- Log analysis\n- Config optimization\nğŸ”® Prevention:\n- Enhanced monitoring\n- Auto backup'
        }
      };

      const expectedActions: Record<string, string> = {
        'daily-report': 'ØªØ­Ù„ÛŒÙ„ Ø¹Ù…Ù„Ú©Ø±Ø¯ØŒ Ø«Ø¨Øª Ø³Ø§Ø¹Ø§Øª Ú©Ø§Ø±ØŒ Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒØ±ÛŒØ²ÛŒ Ø±ÙˆØ² Ø¨Ø¹Ø¯',
        'task-assignment': 'Ø§ÛŒØ¬Ø§Ø¯ ÙˆØ¸ÛŒÙÙ‡ Ø¬Ø¯ÛŒØ¯ØŒ Ø§Ø®ØªØµØ§Øµ Ø¨Ù‡ Ú©Ø§Ø±Ù…Ù†Ø¯ØŒ ØªÙ†Ø¸ÛŒÙ… ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ',
        'leave-request': 'Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø¹ØªØ¨Ø§Ø± Ø¯Ø±Ø®ÙˆØ§Ø³ØªØŒ ØªØ£ÛŒÛŒØ¯ Ù…Ø¯ÛŒØ±ØŒ ØªÙ†Ø¸ÛŒÙ… Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†',
        'technical-report': 'Ø«Ø¨Øª Ù…Ø´Ú©Ù„ØŒ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ Ø±Ø§Ù‡â€ŒØ­Ù„ØŒ Ø¢Ù…Ø§Ø±Ú¯ÛŒØ±ÛŒ Ø§Ø®ØªÙ„Ø§Ù„Ø§Øª'
      };

      const selectedMessage = testMessages[groupType];
      if (!selectedMessage) {
        return res.status(400).json({
          success: false,
          message: 'Invalid group type'
        });
      }

      // Test with both Persian and English formats
      res.json({
        success: true,
        message: 'Test messages generated successfully',
        testData: {
          groupType,
          messages: selectedMessage,
          aiProcessingNote: 'Ø§ÛŒÙ† Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ ØªÙˆØ³Ø· Ø¯Ø³ØªÛŒØ§Ø± Ù‡ÙˆØ´Ù…Ù†Ø¯ ØªØ¬Ø²ÛŒÙ‡ Ùˆ ØªØ­Ù„ÛŒÙ„ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯',
          expectedActions: expectedActions[groupType]
        }
      });

    } catch (error: unknown) {
      console.error('âŒ Error generating test messages:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      res.status(500).json({
        success: false,
        message: 'Error generating test messages',
        error: errorMessage
      });
    }
  });

  // Configure Telegram bot
  app.post('/api/telegram/config', authMiddleware, async (req, res) => {
    try {
      const config = configSchema.parse(req.body);

      // Initialize or reinitialize telegram service
      telegramService = new EnhancedTelegramService(config.token, {
        useWebhook: !config.use_polling,
        webhookUrl: config.webhook_url,
        pollingTimeout: config.polling_timeout
      });

      if (config.use_polling) {
        // Start polling
        await telegramService.startPolling(async (update) => {
          await handleTelegramUpdate(update);
        });

        res.json({
          success: true,
          message: 'Telegram bot configured with polling',
          mode: 'polling'
        });
      } else if (config.webhook_url) {
        // Set webhook
        await telegramService.setWebhook(config.webhook_url);

        res.json({
          success: true,
          message: 'Telegram bot configured with webhook',
          mode: 'webhook',
          webhook_url: config.webhook_url
        });
      } else {
        res.status(400).json({
          error: 'Either enable polling or provide webhook URL'
        });
      }
    } catch (error) {
      console.error('Error configuring Telegram bot:', error);
      res.status(500).json({
        error: 'Failed to configure Telegram bot',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Webhook endpoint
  app.post('/api/telegram/webhook', async (req, res) => {
    try {
      const update = webhookUpdateSchema.parse(req.body);
      await handleTelegramUpdate(update);
      res.status(200).json({ ok: true });
    } catch (error) {
      console.error('Error processing webhook:', error);
      res.status(200).json({ ok: true }); // Telegram requires 200 even on errors
    }
  });

  // ==================== EMPLOYEE MANAGEMENT ====================

  // Get all employees
  app.get('/api/telegram/employees', authMiddleware, async (req, res) => {
    try {
      const allEmployees = await db.select().from(employees).orderBy(desc(employees.createdAt));
      res.json({ employees: allEmployees });
    } catch (error) {
      console.error('Error fetching employees:', error);
      res.status(500).json({ error: 'Failed to fetch employees' });
    }
  });

  // Add new employee
  app.post('/api/telegram/employees', authMiddleware, async (req, res) => {
    try {
      const employeeData = insertEmployeeSchema.parse(req.body);
      const [newEmployee] = await db.insert(employees).values(employeeData).returning();

      res.json({
        success: true,
        message: 'Employee added successfully',
        employee: newEmployee
      });
    } catch (error) {
      console.error('Error adding employee:', error);
      res.status(500).json({
        error: 'Failed to add employee',
        details: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  });

  // Update employee
  app.put('/api/telegram/employees/:id', authMiddleware, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const employeeData = insertEmployeeSchema.partial().parse(req.body);

      const [updatedEmployee] = await db
        .update(employees)
        .set({ ...employeeData, updatedAt: new Date() })
        .where(eq(employees.id, id))
        .returning();

      if (!updatedEmployee) {
        return res.status(404).json({ error: 'Employee not found' });
      }

      res.json({
        success: true,
        message: 'Employee updated successfully',
        employee: updatedEmployee
      });
    } catch (error) {
      console.error('Error updating employee:', error);
      res.status(500).json({ error: 'Failed to update employee' });
    }
  });

  // ==================== TASK MANAGEMENT ====================

  // Get tasks
  app.get('/api/telegram/tasks', authMiddleware, async (req, res) => {
    try {
      const tasks = await db.select().from(employeeTasks).orderBy(desc(employeeTasks.createdAt));
      res.json({ tasks });
    } catch (error) {
      console.error('Error fetching tasks:', error);
      res.status(500).json({ error: 'Failed to fetch tasks' });
    }
  });

  // Create task
  app.post('/api/telegram/tasks', authMiddleware, async (req, res) => {
    try {
      const taskData = insertEmployeeTaskSchema.parse(req.body);
      const [newTask] = await db.insert(employeeTasks).values(taskData).returning();

      res.json({
        success: true,
        message: 'Task created successfully',
        task: newTask
      });
    } catch (error) {
      console.error('Error creating task:', error);
      res.status(500).json({ error: 'Failed to create task' });
    }
  });

  // Update task status
  app.put('/api/telegram/tasks/:id/status', authMiddleware, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { status } = req.body;

      const [updatedTask] = await db
        .update(employeeTasks)
        .set({ 
          status, 
          updatedAt: new Date(),
          completedAt: status === 'completed' ? new Date() : null
        })
        .where(eq(employeeTasks.id, id))
        .returning();

      if (!updatedTask) {
        return res.status(404).json({ error: 'Task not found' });
      }

      res.json({
        success: true,
        message: 'Task status updated successfully',
        task: updatedTask
      });
    } catch (error) {
      console.error('Error updating task status:', error);
      res.status(500).json({ error: 'Failed to update task status' });
    }
  });

  // ==================== MESSAGE MANAGEMENT ====================

  // Get telegram messages
  app.get('/api/telegram/messages', authMiddleware, async (req, res) => {
    try {
      const messages = await db.select().from(telegramMessages).orderBy(desc(telegramMessages.receivedAt));
      res.json({ messages });
    } catch (error) {
      console.error('Error fetching messages:', error);
      res.status(500).json({ error: 'Failed to fetch messages' });
    }
  });

  // ==================== LEAVE REQUESTS ====================

  // Get leave requests
  app.get('/api/telegram/leave-requests', authMiddleware, async (req, res) => {
    try {
      const requests = await db.select().from(leaveRequests).orderBy(desc(leaveRequests.createdAt));
      res.json({ leaveRequests: requests });
    } catch (error) {
      console.error('Error fetching leave requests:', error);
      res.status(500).json({ error: 'Failed to fetch leave requests' });
    }
  });

  // Approve/Deny leave request
  app.put('/api/telegram/leave-requests/:id/review', authMiddleware, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { status, reviewComment } = req.body;

      const [updatedRequest] = await db
        .update(leaveRequests)
        .set({
          status,
          reviewComment,
          reviewedAt: new Date(),
          reviewedById: req.session?.user?.id || 1 // Admin user ID
        })
        .where(eq(leaveRequests.id, id))
        .returning();

      if (!updatedRequest) {
        return res.status(404).json({ error: 'Leave request not found' });
      }

      // Send response to employee via Telegram
      if (telegramService) {
        // Find employee and send notification
        // Implementation will be added later
      }

      res.json({
        success: true,
        message: 'Leave request reviewed successfully',
        leaveRequest: updatedRequest
      });
    } catch (error) {
      console.error('Error reviewing leave request:', error);
      res.status(500).json({ error: 'Failed to review leave request' });
    }
  });

  // ==================== TECHNICAL REPORTS ====================

  // Get technical reports
  app.get('/api/telegram/technical-reports', authMiddleware, async (req, res) => {
    try {
      const reports = await db.select().from(technicalReports).orderBy(desc(technicalReports.createdAt));
      res.json({ technicalReports: reports });
    } catch (error) {
      console.error('Error fetching technical reports:', error);
      res.status(500).json({ error: 'Failed to fetch technical reports' });
    }
  });

  // ==================== DAILY REPORTS ====================

  // Get daily reports
  app.get('/api/telegram/daily-reports', authMiddleware, async (req, res) => {
    try {
      const reports = await db.select().from(dailyReports).orderBy(desc(dailyReports.createdAt));
      res.json({ dailyReports: reports });
    } catch (error) {
      console.error('Error fetching daily reports:', error);
      res.status(500).json({ error: 'Failed to fetch daily reports' });
    }
  });

  // ==================== STATISTICS ====================

  // Get telegram statistics
  app.get('/api/telegram/statistics', authMiddleware, async (req, res) => {
    try {
      const stats = {
        totalEmployees: await db.select().from(employees).then(rows => rows.length),
        activeTasks: await db.select().from(employeeTasks).where(eq(employeeTasks.status, 'pending')).then(rows => rows.length),
        pendingLeaveRequests: await db.select().from(leaveRequests).where(eq(leaveRequests.status, 'pending')).then(rows => rows.length),
        unprocessedMessages: await db.select().from(telegramMessages).where(eq(telegramMessages.processed, false)).then(rows => rows.length),
        dailyReportsToday: await db.select().from(dailyReports).where(eq(dailyReports.reportDate, new Date().toLocaleDateString('fa-IR'))).then(rows => rows.length)
      };

      res.json({ statistics: stats });
    } catch (error) {
      console.error('Error fetching statistics:', error);
      res.status(500).json({ error: 'Failed to fetch statistics' });
    }
  });
}

// ==================== TELEGRAM UPDATE HANDLER ====================

async function handleTelegramUpdate(update: any) {
  try {
    console.log('ğŸ¤– Processing Telegram update:', update.parsedMessage?.type || 'unknown');

    const parsedMessage = update.parsedMessage;
    const entities = update.extractedEntities;
    const commandResponse = update.commandResponse;

    if (!parsedMessage) return;

    // Find or create employee
    let employee = await db.select().from(employees)
      .where(eq(employees.telegramId, parsedMessage.employeeId.toString()))
      .then(rows => rows[0]);

    if (!employee) {
      // Create new employee
      const [newEmployee] = await db.insert(employees).values({
        telegramId: parsedMessage.employeeId.toString(),
        firstName: parsedMessage.employeeName.split(' ')[0],
        lastName: parsedMessage.employeeName.split(' ')[1] || '',
        username: parsedMessage.employeeName,
        isActive: true
      }).returning();
      employee = newEmployee;
    }

    // Save telegram message
    const [savedMessage] = await db.insert(telegramMessages).values({
      messageId: parsedMessage.messageId.toString(),
      chatId: update.originalUpdate.message?.chat?.id?.toString() || '',
      fromUserId: parsedMessage.employeeId.toString(),
      employeeId: employee.id,
      text: parsedMessage.data?.content || '',
      messageType: parsedMessage.type,
      parsedData: parsedMessage.data,
      entities: entities,
      processed: true,
      responseRequired: !!commandResponse,
      responseText: commandResponse?.responseText,
      receivedAt: new Date(parsedMessage.timestamp * 1000),
      processedAt: new Date()
    }).returning();

    // Handle specific message types
    switch (parsedMessage.type) {
      case 'leave_request':
        await handleLeaveRequest(parsedMessage, employee.id, savedMessage.id);
        break;
      case 'technical_report':
        await handleTechnicalReport(parsedMessage, employee.id, savedMessage.id);
        break;
      case 'daily_report':
        await handleDailyReport(parsedMessage, employee.id, savedMessage.id);
        break;
    }

    // Create task if needed
    if (commandResponse?.createTask) {
      await createTaskFromMessage(parsedMessage, employee.id, savedMessage.id);
    }

    // Send response if needed
    if (commandResponse?.shouldRespond && telegramService) {
      await telegramService.sendMessage(
        update.originalUpdate.message.chat.id,
        commandResponse.responseText
      );

      // Update message as responded
      await db.update(telegramMessages)
        .set({ responseSent: true })
        .where(eq(telegramMessages.id, savedMessage.id));
    }

  } catch (error) {
    console.error('Error handling Telegram update:', error);
  }
}

async function handleLeaveRequest(parsedMessage: any, employeeId: number, messageId: number) {
  try {
    await db.insert(leaveRequests).values({
      employeeId,
      telegramMessageId: messageId,
      requestDate: parsedMessage.data.date,
      duration: parsedMessage.data.duration,
      reason: parsedMessage.data.reason,
      status: 'pending'
    });
  } catch (error) {
    console.error('Error handling leave request:', error);
  }
}

async function handleTechnicalReport(parsedMessage: any, employeeId: number, messageId: number) {
  try {
    await db.insert(technicalReports).values({
      employeeId,
      telegramMessageId: messageId,
      issue: parsedMessage.data.issue,
      status: parsedMessage.data.status || 'reported',
      priority: 'medium'
    });
  } catch (error) {
    console.error('Error handling technical report:', error);
  }
}

async function handleDailyReport(parsedMessage: any, employeeId: number, messageId: number) {
  try {
    await db.insert(dailyReports).values({
      employeeId,
      telegramMessageId: messageId,
      reportDate: new Date().toLocaleDateString('fa-IR'),
      tasks: parsedMessage.data.tasks || []
    });
  } catch (error) {
    console.error('Error handling daily report:', error);
  }
}

  // ==================== STATUS AND SETTINGS ENDPOINTS ====================

  // Get Telegram bot status
  app.get('/api/telegram/status', authMiddleware, async (req, res) => {
    try {
      res.json({
        success: true,
        status: telegramService ? 'connected' : 'disconnected',
        botInitialized: !!telegramService,
        lastUpdate: new Date().toISOString()
      });
    } catch (error: unknown) {
      console.error('âŒ Error getting telegram status:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      res.status(500).json({
        success: false,
        message: 'Error getting telegram status',
        error: errorMessage
      });
    }
  });

  // Get Telegram settings
  app.get('/api/telegram/settings', authMiddleware, async (req, res) => {
    try {
      // Return basic settings info without exposing sensitive data
      res.json({
        success: true,
        settings: {
          configured: !!telegramService,
          pollingEnabled: true,
          webhookEnabled: false
        }
      });
    } catch (error: unknown) {
      console.error('âŒ Error getting telegram settings:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      res.status(500).json({
        success: false,
        message: 'Error getting telegram settings',
        error: errorMessage
      });
    }
  });
}

// ==================== HELPER FUNCTIONS ====================

async function createTaskFromMessage(parsedMessage: any, employeeId: number, messageId: number) {
  try {
    const [newTask] = await db.insert(employeeTasks).values({
      title: `Task from ${parsedMessage.type}`,
      description: JSON.stringify(parsedMessage.data),
      type: 'telegram_command',
      priority: 'medium',
      status: 'pending',
      assignedToId: employeeId,
      createdById: employeeId,
      metadata: { sourceMessageId: messageId }
    }).returning();

    // Update message to link the created task
    await db.update(telegramMessages)
      .set({ 
        taskCreated: true, 
        createdTaskId: newTask.id 
      })
      .where(eq(telegramMessages.id, messageId));

  } catch (error) {
    console.error('Error creating task from message:', error);
  }
}