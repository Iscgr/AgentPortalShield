Comprehensive Architectural Migration Guide for MarFaNet

ATTENTION CLAUDE SONNET 4:

This document provides an exhaustively detailed blueprint for restructuring the MarFaNet application, with atomic implementation details for each component. Please implement these architectural changes according to the following specifications.
1. Safely Removing the CRM Panel
Component Identification Strategy

First, identify all components related to the CRM panel that should be removed:

    All CRM dashboard pages and their components (typically in a directory structure like /pages/crm/ or /app/crm/)
    CRM-specific API endpoints (usually in /api/crm/ or similar)
    CRM-only database entities (tables with crm_ prefix or exclusively used by CRM functions)
    CRM-related navigation elements in the sidebar
    CRM user role definitions that aren't needed for admin operations

Safe Removal Process

    Navigation System Modification:
        Find the navigation component that renders the sidebar (often named Sidebar.jsx, Navigation.tsx or similar)
        Locate the array of navigation items (often a constant named navItems, menuItems, etc.)
        Remove all objects with paths containing /crm/ or with titles related to CRM
        Example transformation:
    Code

// FROM:
const navItems = [
  { label: 'Dashboard', path: '/admin/dashboard', icon: 'dashboard' },
  { label: 'CRM', path: '/crm', icon: 'people' }, // REMOVE THIS
  { label: 'CRM Tasks', path: '/crm/tasks', icon: 'task' }, // REMOVE THIS
  { label: 'Accounting', path: '/admin/accounting', icon: 'money' },
];

// TO:
const navItems = [
  { label: 'Dashboard', path: '/admin/dashboard', icon: 'dashboard' },
  { label: 'Accounting', path: '/admin/accounting', icon: 'money' },
];

Route System Cleanup:

    In your routing configuration (Next.js pages directory or app router), identify all CRM-related routes
    Remove these route files completely, including any associated components
    Check for shared layouts that might be affected (usually named layout.js or layout.tsx)
    If layouts are shared, carefully extract the CRM routes while preserving layout for admin routes

API Layer Modification:

    Identify API endpoints in your /api/ directory that specifically serve CRM functionality
    Remove these endpoints completely
    For endpoints serving both CRM and admin functionality:
        Modify handler functions to check for admin permissions only
        Remove CRM-specific processing logic
        Update response objects to exclude CRM-specific fields

Database Access Layer:

    In your database schema definition files (often named schema.ts, models.js, etc.):
        Identify entities used exclusively by CRM (e.g., crmTasks, crmActivities)
        Remove these entity definitions completely
        For shared entities (like representatives), preserve them but remove CRM-specific fields
    Update any ORM queries or raw SQL queries that reference removed entities
    Example transformation:

Code

// FROM:
export const schema = {
  representatives: { /* fields */ },
  invoices: { /* fields */ },
  crmTasks: { /* fields */ }, // REMOVE THIS
  crmNotes: { /* fields */ }, // REMOVE THIS
};

// TO:
export const schema = {
  representatives: { /* fields */ },
  invoices: { /* fields */ },
};

Authentication System Updates:

    Locate your permissions definition file (often named permissions.js, roles.ts, etc.)
    Remove CRM-specific roles and permissions
    Update any middleware or guards that check for these permissions
    Example transformation:

Code

    // FROM:
    const roles = {
      ADMIN: ['admin.view', 'admin.edit', 'admin.delete'],
      CRM_MANAGER: ['crm.view', 'crm.edit', 'crm.delete'], // REMOVE THIS
      CRM_AGENT: ['crm.view', 'crm.limited_edit'], // REMOVE THIS
    };

    // TO:
    const roles = {
      ADMIN: ['admin.view', 'admin.edit', 'admin.delete'],
    };

    Verification Process:
        Create a checklist of admin functionality to verify:
            Dashboard loads correctly
            Representative management works
            Invoice creation and management functions
            Reports generate correctly
            User management works for admin users
        Test each item on the checklist thoroughly
        Look for console errors that might indicate broken dependencies
        Check network requests for 404 errors that might indicate missing endpoints

2. Enhancing the Telegram Bot
Preserving Existing Functionality

The current Telegram bot functionality must remain intact:

    Locate the current Telegram service implementation (likely named TelegramService.js, telegram-bot.ts, etc.)
    Identify the methods used for invoice notifications:
    JavaScript

    // Example methods to preserve:
    sendInvoiceNotification(invoice, representative) { /* ... */ }
    sendPaymentReminder(invoice, representative) { /* ... */ }
    notifyNewRepresentative(representative) { /* ... */ }

    Create a backup of this file before making any changes
    When enhancing, extend the existing class rather than creating a new one

Message Parsing Implementation

    Group-Specific Parsing Strategies:

    Create distinct parsers for each group type shown in your screenshot:
    JavaScript

class MessageParser {
  // Leave request parsing
  parseLeaveRequest(message) {
    // Expected format: #درخواست_مرخصی {date} به مدت {duration} به علت {reason}
    const regex = /#درخواست_مرخصی\s+(\d{4}\/\d{2}\/\d{2})\s+به\s+مدت\s+(.+?)\s+به\s+علت\s+(.+)/i;
    const match = message.text.match(regex);
    
    if (match) {
      return {
        type: 'leave_request',
        date: match[1], // Extracted date
        duration: match[2], // Extracted duration
        reason: match[3], // Extracted reason
        employeeId: message.from.id,
        employeeName: message.from.username || `${message.from.first_name} ${message.from.last_name}`,
        messageId: message.message_id,
        timestamp: message.date
      };
    }
    return null; // Not a valid leave request
  }
  
  // Technical report parsing
  parseTechnicalReport(message) {
    // Expected format: #گزارش_فنی {issue} - وضعیت: {status}
    const regex = /#گزارش_فنی\s+(.+?)\s+-\s+وضعیت:\s+(.+)/i;
    const match = message.text.match(regex);
    
    if (match) {
      return {
        type: 'technical_report',
        issue: match[1], // Extracted issue
        status: match[2], // Extracted status
        employeeId: message.from.id,
        employeeName: message.from.username || `${message.from.first_name} ${message.from.last_name}`,
        messageId: message.message_id,
        timestamp: message.date
      };
    }
    return null; // Not a valid technical report
  }
  
  // Responsibility assignment parsing
  parseResponsibility(message) {
    // Expected format: #مسئولیت {task} - مسئول: {assignee} - مهلت: {deadline}
    const regex = /#مسئولیت\s+(.+?)\s+-\s+مسئول:\s+(.+?)\s+-\s+مهلت:\s+(.+)/i;
    const match = message.text.match(regex);
    
    if (match) {
      return {
        type: 'responsibility',
        task: match[1], // Extracted task
        assignee: match[2], // Extracted assignee
        deadline: match[3], // Extracted deadline
        employeeId: message.from.id,
        employeeName: message.from.username || `${message.from.first_name} ${message.from.last_name}`,
        messageId: message.message_id,
        timestamp: message.date
      };
    }
    return null; // Not a valid responsibility assignment
  }
  
  // Daily work report parsing
  parseDailyReport(message) {
    // Expected format: #گزارش_روزانه\n{task1}: {status1}\n{task2}: {status2}...
    const regex = /#گزارش_روزانه\n([\s\S]+)/i;
    const match = message.text.match(regex);
    
    if (match) {
      const reportBody = match[1];
      const tasks = reportBody.split('\n').map(line => {
        const [task, status] = line.split(':').map(item => item.trim());
        return { task, status };
      }).filter(item => item.task && item.status);
      
      return {
        type: 'daily_report',
        tasks: tasks,
        employeeId: message.from.id,
        employeeName: message.from.username || `${message.from.first_name} ${message.from.last_name}`,
        messageId: message.message_id,
        timestamp: message.date
      };
    }
    return null; // Not a valid daily report
  }
  
  // General message parsing
  parseGeneralMessage(message) {
    // Any message in the general channel that doesn't match other patterns
    return {
      type: 'general_message',
      content: message.text,
      employeeId: message.from.id,
      employeeName: message.from.username || `${message.from.first_name} ${message.from.last_name}`,
      messageId: message.message_id,
      timestamp: message.date
    };
  }
  
  // Master parser that tries all parsers in sequence
  parseMessage(message, groupType) {
    switch (groupType) {
      case 'leave_requests':
        return this.parseLeaveRequest(message) || this.parseGeneralMessage(message);
      case 'technical_reports':
        return this.parseTechnicalReport(message) || this.parseGeneralMessage(message);
      case 'responsibilities':
        return this.parseResponsibility(message) || this.parseGeneralMessage(message);
      case 'daily_reports':
        return this.parseDailyReport(message) || this.parseGeneralMessage(message);
      case 'general':
      default:
        return this.parseGeneralMessage(message);
    }
  }
}

Content Extraction Logic:

Add methods to extract specific entities from messages:
JavaScript

    class EntityExtractor {
      // Extract representative mentions
      extractRepresentativeNames(text) {
        // Look for patterns like "نماینده: {name}" or "نماینده {name}"
        const regex = /نماینده:?\s+([^\n,]+)/gi;
        const matches = [...text.matchAll(regex)];
        return matches.map(match => match[1].trim());
      }
      
      // Extract products mentioned
      extractProductReferences(text) {
        // Your product catalog would inform this regex
        const productRegex = /محصول:?\s+([^\n,]+)/gi;
        const matches = [...text.matchAll(productRegex)];
        return matches.map(match => match[1].trim());
      }
      
      // Extract date references
      extractDateReferences(text) {
        // Persian calendar dates in format YYYY/MM/DD
        const dateRegex = /(\d{4}\/\d{2}\/\d{2})/g;
        return [...text.matchAll(dateRegex)].map(match => match[1]);
      }
      
      // Extract action items
      extractActionItems(text) {
        // Look for phrases that indicate actions needed
        const actionPhrases = [
          { regex: /باید\s+(.+?)(?:\.|$)/gi, priority: 'high' },
          { regex: /لطفا\s+(.+?)(?:\.|$)/gi, priority: 'medium' },
          { regex: /می\s?توانید\s+(.+?)(?:\.|$)/gi, priority: 'low' }
        ];
        
        let actions = [];
        for (const { regex, priority } of actionPhrases) {
          const matches = [...text.matchAll(regex)];
          actions = actions.concat(
            matches.map(match => ({
              action: match[1].trim(),
              priority
            }))
          );
        }
        return actions;
      }
    }

Complete Telegram Bot Command Taxonomy

    Command Structure Definition:
    JavaScript

const BOT_COMMANDS = {
  // System commands - used by administrators
  SYSTEM: {
    START: '/start',
    HELP: '/help',
    SETTINGS: '/settings',
    STATUS: '/status',
    REGISTER: '/register',
  },
  
  // Report commands - used by employees
  REPORTS: {
    DAILY: '#گزارش_روزانه',
    TECHNICAL: '#گزارش_فنی',
    ISSUE: '#مشکل',
    SUCCESS: '#موفقیت',
  },
  
  // Request commands - used by employees
  REQUESTS: {
    LEAVE: '#درخواست_مرخصی',
    SUPPORT: '#درخواست_پشتیبانی',
    MATERIAL: '#درخواست_ابزار',
  },
  
  // Task commands - used by managers and the bot
  TASKS: {
    ASSIGN: '#وظیفه',
    COMPLETE: '#انجام_شد',
    FOLLOW_UP: '#پیگیری',
    DEADLINE: '#مهلت',
  },
  
  // Representative commands - used by CRM team
  REPRESENTATIVES: {
    NEW: '#نماینده_جدید',
    UPDATE: '#بروزرسانی_نماینده',
    INACTIVE: '#نماینده_غیرفعال',
    SALES: '#آمار_فروش',
  }
};

// Command parameters definition
const COMMAND_PARAMETERS = {
  [BOT_COMMANDS.REQUESTS.LEAVE]: [
    { name: 'date', regex: /(\d{4}\/\d{2}\/\d{2})/, required: true },
    { name: 'duration', regex: /به\s+مدت\s+(.+?)(?:\s|$)/, required: true },
    { name: 'reason', regex: /به\s+علت\s+(.+)$/, required: true }
  ],
  
  [BOT_COMMANDS.TASKS.ASSIGN]: [
    { name: 'task', regex: /وظیفه:\s+(.+?)(?:\s|$)/, required: true },
    { name: 'assignee', regex: /مسئول:\s+(.+?)(?:\s|$)/, required: true },
    { name: 'deadline', regex: /مهلت:\s+(.+?)(?:\s|$)/, required: false }
  ],
  
  // Add parameter definitions for other commands...
};

// Response templates for bot replies
const RESPONSE_TEMPLATES = {
  LEAVE_REQUEST_RECEIVED: 'درخواست مرخصی شما برای تاریخ {date} به مدت {duration} دریافت شد و در حال بررسی است.',
  LEAVE_REQUEST_APPROVED: 'درخواست مرخصی شما برای تاریخ {date} تایید شد.',
  LEAVE_REQUEST_DENIED: 'متاسفانه درخواست مرخصی شما برای تاریخ {date} تایید نشد. دلیل: {reason}',
  
  TASK_ASSIGNED: 'وظیفه جدید برای شما تعریف شد:\n{task}\nمهلت: {deadline}',
  TASK_REMINDER: 'یادآوری: {deadline} مهلت انجام وظیفه "{task}" است.',
  TASK_COMPLETED: 'وظیفه "{task}" با موفقیت تکمیل شد.',
  
  REPORT_ACKNOWLEDGED: 'گزارش شما دریافت شد. با تشکر از همکاری شما.',
  
  // Add more response templates...
};

Command Handling Logic:
JavaScript

    class CommandHandler {
      constructor(telegramService, entityExtractor) {
        this.telegramService = telegramService;
        this.entityExtractor = entityExtractor;
        this.commands = BOT_COMMANDS;
        this.parameters = COMMAND_PARAMETERS;
        this.templates = RESPONSE_TEMPLATES;
      }
      
      // Identify command type from message
      identifyCommand(message) {
        const text = message.text || '';
        
        // Check each command category
        for (const category in this.commands) {
          for (const cmd in this.commands[category]) {
            const commandText = this.commands[category][cmd];
            if (text.startsWith(commandText)) {
              return { 
                category, 
                command: cmd, 
                fullCommand: commandText,
                text: text.substring(commandText.length).trim() 
              };
            }
          }
        }
        
        return { category: 'UNKNOWN', command: null, fullCommand: null, text };
      }
      
      // Extract parameters based on command
      extractParameters(commandInfo, message) {
        if (!commandInfo.fullCommand || !this.parameters[commandInfo.fullCommand]) {
          return {};
        }
        
        const parameterDefinitions = this.parameters[commandInfo.fullCommand];
        const text = message.text || '';
        const params = {};
        
        for (const param of parameterDefinitions) {
          const match = text.match(param.regex);
          if (match) {
            params[param.name] = match[1].trim();
          } else if (param.required) {
            return null; // Missing required parameter
          }
        }
        
        return params;
      }
      
      // Generate response based on command and parameters
      generateResponse(commandInfo, parameters) {
        let template = '';
        
        // Select appropriate template based on command
        switch (`${commandInfo.category}.${commandInfo.command}`) {
          case 'REQUESTS.LEAVE':
            template = this.templates.LEAVE_REQUEST_RECEIVED;
            break;
          case 'TASKS.ASSIGN':
            template = this.templates.TASK_ASSIGNED;
            break;
          // Add cases for other commands
          default:
            template = this.templates.REPORT_ACKNOWLEDGED;
        }
        
        // Replace placeholders with actual values
        let response = template;
        for (const [key, value] of Object.entries(parameters)) {
          response = response.replace(`{${key}}`, value);
        }
        
        return response;
      }
      
      // Handle incoming command
      async handleCommand(message, chatInfo) {
        const commandInfo = this.identifyCommand(message);
        
        // Unknown command
        if (commandInfo.category === 'UNKNOWN') {
          return null;
        }
        
        // Extract parameters
        const parameters = this.extractParameters(commandInfo, message);
        
        // Missing required parameters
        if (parameters === null) {
          return {
            responseText: `فرمت دستور نادرست است. لطفا راهنما را مطالعه کنید.`,
            shouldRespond: true,
            createTask: false
          };
        }
        
        // Process specific command types
        switch (`${commandInfo.category}.${commandInfo.command}`) {
          case 'REQUESTS.LEAVE':
            await this.processLeaveRequest(message, parameters);
            break;
          case 'TASKS.ASSIGN':
            await this.processTaskAssignment(message, parameters);
            break;
          // Add cases for other commands
        }
        
        // Generate and return response
        return {
          responseText: this.generateResponse(commandInfo, parameters),
          shouldRespond: true,
          createTask: commandInfo.category === 'TASKS'
        };
      }
      
      // Implement command-specific processing methods
      async processLeaveRequest(message, parameters) {
        // Store the leave request in database
        // Notify appropriate manager
      }
      
      async processTaskAssignment(message, parameters) {
        // Create task record
        // Notify assignee
        // Schedule reminders if deadline provided
      }
      
      // Add processing methods for other commands...
    }

Extended Bot Architecture

    Enhanced Telegram Service:
    JavaScript

    class EnhancedTelegramService {
      constructor(token, config = {}) {
        this.token = token;
        this.apiBase = `https://api.telegram.org/bot${token}`;
        this.config = {
          useWebhook: false,
          webhookUrl: '',
          pollingTimeout: 60,
          ...config
        };
        this.messageParser = new MessageParser();
        this.entityExtractor = new EntityExtractor();
        this.commandHandler = new CommandHandler(this, this.entityExtractor);
      }
      
      // Core API methods
      async apiRequest(method, params = {}) {
        try {
          const response = await fetch(`${this.apiBase}/${method}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(params)
          });
          
          const data = await response.json();
          
          if (!data.ok) {
            console.error(`Telegram API error (${method}):`, data);
            throw new Error(`Telegram API error: ${data.description}`);
          }
          
          return data.result;
        } catch (error) {
          console.error(`Error in Telegram API request (${method}):`, error);
          throw error;
        }
      }
      
      // Send message to a chat
      async sendMessage(chatId, text, options = {}) {
        return this.apiRequest('sendMessage', {
          chat_id: chatId,
          text,
          parse_mode: 'HTML',
          ...options
        });
      }
      
      // Join a group by invite link
      async joinGroup(inviteLink) {
        // Extract the invite code
        const match = inviteLink.match(/t\.me\/\+([a-zA-Z0-9_-]+)/);
        if (!match) throw new Error('Invalid invite link format');
        
        const inviteCode = match[1];
        return this.apiRequest('joinChat', {
          invite_link: `https://t.me/+${inviteCode}`
        });
      }
      
      // Set or update webhook
      async setWebhook(url, options = {}) {
        return this.apiRequest('setWebhook', {
          url,
          allowed_updates: ['message', 'edited_message', 'callback_query'],
          ...options
        });
      }
      
      // Remove webhook and use polling
      async deleteWebhook() {
        return this.apiRequest('deleteWebhook');
      }
      
      // Start long polling for updates
      async startPolling(callback) {
        let offset = 0;
        
        const poll = async () => {
          try {
            const updates = await this.apiRequest('getUpdates', {
              offset,
              timeout: this.config.pollingTimeout,
              allowed_updates: ['message', 'edited_message', 'callback_query']
            });
            
            if (updates.length > 0) {
              offset = updates[updates.length - 1].update_id + 1;
              
              for (const update of updates) {
                await this.processUpdate(update, callback);
              }
            }
            
            // Continue polling
            setTimeout(poll, 1000);
          } catch (error) {
            console.error('Polling error:', error);
            // Retry after delay
            setTimeout(poll, 5000);
          }
        };
        
        // Start polling loop
        poll();
      }
      
      // Process a single update (from webhook or polling)
      async processUpdate(update, callback) {
        // Extract the message
        const message = update.message || update.edited_message || (update.callback_query && update.callback_query.message);
        
        if (!message) return;
        
        // Determine group type from chat title or ID
        const groupType = this.identifyGroupType(message.chat);
        
        // Parse the message
        const parsedData = this.messageParser.parseMessage(message, groupType);
        
        if (parsedData) {
          // Process commands if present
          const commandResult = await this.commandHandler.handleCommand(message, { groupType });
          
          // Store the message in the database
          await this.storeMessage(parsedData);
          
          // Execute the callback with parsed data
          if (callback) {
            await callback(parsedData, commandResult);
          }
          
          // Send command response if needed
          if (commandResult && commandResult.shouldRespond) {
            await this.sendMessage(message.chat.id, commandResult.responseText, {
              reply_to_message_id: message.message_id
            });
          }
        }
      }
      
      // Determine group type based on chat title or ID
      identifyGroupType(chat) {
        const title = chat.title || '';
        const id = chat.id.toString();
        
        // Map known group IDs
        const knownGroups = {
          '-1001234567890': 'leave_requests',
          '-1001234567891': 'technical_reports',
          // Add other group IDs
        };
        
        // First try to match by ID
        if (knownGroups[id]) {
          return knownGroups[id];
        }
        
        // Then try to match by title
        if (/مرخص/i.test(title)) return 'leave_requests';
        if (/فنی/i.test(title)) return 'technical_reports';
        if (/مسئولیت/i.test(title)) return 'responsibilities';
        if (/گزارش.+روزانه/i.test(title)) return 'daily_reports';
        if (/عمومی/i.test(title)) return 'general';
        
        // Default
        return 'unknown';
      }
      
      // Store message in database
      async storeMessage(parsedData) {
        // Implementation depends on your database structure
        // This is a placeholder for where you would save the message
      }
      
      // Legacy methods for invoice notifications (preserved from original)
      async sendInvoiceNotification(invoice, representative) {
        // Original implementation preserved
      }
      
      async sendPaymentConfirmation(payment, representative) {
        // Original implementation preserved
      }
    }

3. Admin Panel Enhancements
Database Schema Details

    AI Settings Entity:
    JavaScript

// Database field definitions with complete detail
const aiSettings = {
  tableName: 'ai_settings',
  columns: {
    id: {
      type: 'serial',
      primaryKey: true,
      description: 'Unique identifier for settings record'
    },
    grokApiKey: {
      type: 'text',
      nullable: false,
      defaultValue: '',
      description: 'API key for xAI Grok integration',
      encrypted: true // Indicates this field should be encrypted in storage
    },
    grokApiEndpoint: {
      type: 'text',
      nullable: false,
      defaultValue: 'https://api.grok.x.ai/v1',
      description: 'API endpoint URL for xAI Grok'
    },
    aiTemperature: {
      type: 'real',
      nullable: false,
      defaultValue: 0.7,
      minValue: 0.0,
      maxValue: 1.0,
      description: 'Controls randomness in AI responses (0-1)'
    },
    aiMaxTokens: {
      type: 'integer',
      nullable: false,
      defaultValue: 4096,
      minValue: 100,
      maxValue: 16000,
      description: 'Maximum tokens in AI responses'
    },
    createdAt: {
      type: 'timestamp',
      defaultValue: 'CURRENT_TIMESTAMP',
      description: 'Record creation timestamp'
    },
    updatedAt: {
      type: 'timestamp',
      defaultValue: 'CURRENT_TIMESTAMP',
      onUpdate: 'CURRENT_TIMESTAMP',
      description: 'Record last update timestamp'
    }
  },
  indices: [
    // No indices needed for this table as it will only have one row
  ],
  constraints: [
    // Single record constraint (optional implementation)
    {
      type: 'check',
      expression: 'id = 1',
      description: 'Ensures only one settings record exists'
    }
  ]
};

Telegram Activities Entity:
JavaScript

const telegramActivities = {
  tableName: 'telegram_activities',
  columns: {
    id: {
      type: 'serial',
      primaryKey: true,
      description: 'Unique identifier for activity'
    },
    type: {
      type: 'text',
      nullable: false,
      description: 'Activity type (message, report, task, etc.)',
      allowedValues: [
        'leave_request', 
        'technical_report', 
        'responsibility', 
        'daily_report', 
        'general_message'
      ]
    },
    content: {
      type: 'text',
      nullable: false,
      description: 'Raw message content'
    },
    parsedData: {
      type: 'jsonb',
      nullable: true,
      description: 'Structured data extracted from message'
    },
    employeeName: {
      type: 'text',
      nullable: false,
      description: 'Name of employee who sent the message'
    },
    employeeId: {
      type: 'text',
      nullable: false,
      description: 'Telegram ID of employee',
      index: true
    },
    groupId: {
      type: 'text',
      nullable: false,
      description: 'Telegram group ID where message was sent',
      index: true
    },
    groupName: {
      type: 'text',
      nullable: false,
      description: 'Name of Telegram group'
    },
    messageId: {
      type: 'text',
      nullable: false,
      description: 'Telegram message ID',
      uniqueWith: ['groupId']
    },
    processed: {
      type: 'boolean',
      defaultValue: false,
      description: 'Whether message has been processed',
      index: true
    },
    aiProcessed: {
      type: 'boolean',
      defaultValue: false,
      description: 'Whether AI has processed this message',
      index: true
    },
    aiResponse: {
      type: 'text',
      nullable: true,
      description: 'AI response to this message'
    },
    createdAt: {
      type: 'timestamp',
      defaultValue: 'CURRENT_TIMESTAMP',
      description: 'Record creation timestamp',
      index: true
    }
  },
  indices: [
    {
      name: 'telegram_activities_employee_type_idx',
      columns: ['employeeId', 'type'],
      description: 'Index for querying activities by employee and type'
    },
    {
      name: 'telegram_activities_created_at_idx',
      columns: ['createdAt'],
      description: 'Index for chronological queries'
    }
  ],
  constraints: [
    {
      type: 'unique',
      columns: ['groupId', 'messageId'],
      description: 'Ensures no duplicate message processing'
    }
  ]
};

CRM Employees Entity:
JavaScript

const crmEmployees = {
  tableName: 'crm_employees',
  columns: {
    id: {
      type: 'serial',
      primaryKey: true,
      description: 'Unique identifier for employee'
    },
    name: {
      type: 'text',
      nullable: false,
      description: 'Full name of employee'
    },
    telegramUsername: {
      type: 'text',
      nullable: false,
      description: 'Telegram username',
      unique: true
    },
    telegramId: {
      type: 'text',
      nullable: true,
      description: 'Telegram user ID',
      unique: true
    },
    isActive: {
      type: 'boolean',
      defaultValue: true,
      description: 'Whether employee is currently active',
      index: true
    },
    position: {
      type: 'text',
      nullable: true,
      description: 'Employee job position'
    },
    department: {
      type: 'text',
      nullable: true,
      description: 'Employee department'
    },
    managerId: {
      type: 'integer',
      nullable: true,
      description: 'ID of employee\'s manager',
      references: {
        table: 'crm_employees',
        column: 'id'
      }
    },
    contactInfo: {
      type: 'jsonb',
      nullable: true,
      description: 'Additional contact information'
    },
    createdAt: {
      type: 'timestamp',
      defaultValue: 'CURRENT_TIMESTAMP',
      description: 'Record creation timestamp'
    },
    updatedAt: {
      type: 'timestamp',
      defaultValue: 'CURRENT_TIMESTAMP',
      onUpdate: 'CURRENT_TIMESTAMP',
      description: 'Record last update timestamp'
    }
  },
  indices: [
    {
      name: 'crm_employees_telegram_username_idx',
      columns: ['telegramUsername'],
      description: 'Index for looking up employees by Telegram username'
    },
    {
      name: 'crm_employees_is_active_idx',
      columns: ['isActive'],
      description: 'Index for filtering active/inactive employees'
    }
  ],
  constraints: [
    {
      type: 'unique',
      columns: ['telegramUsername'],
      description: 'Ensures unique Telegram usernames'
    },
    {
      type: 'unique',
      columns: ['telegramId'],
      description: 'Ensures unique Telegram IDs'
    }
  ]
};

CRM Tasks Entity:
JavaScript

const crmTasks = {
  tableName: 'crm_tasks',
  columns: {
    id: {
      type: 'serial',
      primaryKey: true,
      description: 'Unique identifier for task'
    },
    title: {
      type: 'text',
      nullable: false,
      description: 'Task title'
    },
    description: {
      type: 'text',
      nullable: false,
      description: 'Detailed task description'
    },
    assignedToId: {
      type: 'integer',
      nullable: true,
      description: 'Employee ID task is assigned to',
      references: {
        table: 'crm_employees',
        column: 'id'
      },
      index: true
    },
    createdById: {
      type: 'integer',
      nullable: true,
      description: 'Employee or admin ID who created the task',
      index: true
    },
    isSystemGenerated: {
      type: 'boolean',
      defaultValue: false,
      description: 'Whether task was generated by AI'
    },
    representativeId: {
      type: 'integer',
      nullable: true,
      description: 'Representative ID if task is related to a representative',
      references: {
        table: 'representatives',
        column: 'id'
      },
      index: true
    },
    status: {
      type: 'text',
      nullable: false,
      defaultValue: 'pending',
      description: 'Current status of task',
      allowedValues: [
        'pending', 'in_progress', 'completed', 'cancelled', 'delayed'
      ],
      index: true
    },
    priority: {
      type: 'text',
      nullable: false,
      defaultValue: 'medium',
      description: 'Task priority level',
      allowedValues: ['low', 'medium', 'high', 'urgent'],
      index: true
    },
    category: {
      type: 'text',
      nullable: true,
      description: 'Task category',
      index: true
    },
    dueDate: {
      type: 'timestamp',
      nullable: true,
      description: 'Task deadline',
      index: true
    },
    completedAt: {
      type: 'timestamp',
      nullable: true,
      description: 'When task was completed'
    },
    reminderSent: {
      type: 'boolean',
      defaultValue: false,
      description: 'Whether reminder has been sent'
    },
    reminderDate: {
      type: 'timestamp',
      nullable: true,
      description: 'When to send reminder',
      index: true
    },
    sourceMessageId: {
      type: 'integer',
      nullable: true,
      description: 'ID of telegram_activities that generated this task',
      references: {
        table: 'telegram_activities',
        column: 'id'
      }
    },
    createdAt: {
      type: 'timestamp',
      defaultValue: 'CURRENT_TIMESTAMP',
      description: 'Record creation timestamp'
    },
    updatedAt: {
      type: 'timestamp',
      defaultValue: 'CURRENT_TIMESTAMP',
      onUpdate: 'CURRENT_TIMESTAMP',
      description: 'Record last update timestamp'
    }
  },
  indices: [
    {
      name: 'crm_tasks_assigned_status_idx',
      columns: ['assignedToId', 'status'],
      description: 'Index for querying tasks by assignee and status'
    },
    {
      name: 'crm_tasks_due_date_idx',
      columns: ['dueDate'],
      description: 'Index for deadline queries'
    },
    {
      name: 'crm_tasks_priority_status_idx',
      columns: ['priority', 'status'],
      description: 'Index for priority-based task queries'
    }
  ]
};

AI Directives Entity:
JavaScript

    const aiDirectives = {
      tableName: 'ai_directives',
      columns: {
        id: {
          type: 'serial',
          primaryKey: true,
          description: 'Unique identifier for directive'
        },
        type: {
          type: 'text',
          nullable: false,
          description: 'Directive type',
          allowedValues: [
            'general', 
            'task_generation', 
            'response_style', 
            'follow_up', 
            'performance_evaluation'
          ],
          index: true
        },
        title: {
          type: 'text',
          nullable: false,
          description: 'Short title for the directive'
        },
        content: {
          type: 'text',
          nullable: false,
          description: 'Full directive content'
        },
        isActive: {
          type: 'boolean',
          defaultValue: true,
          description: 'Whether directive is currently active',
          index: true
        },
        priority: {
          type: 'integer',
          defaultValue: 10,
          description: 'Execution priority (lower numbers = higher priority)',
          index: true
        },
        scheduled: {
          type: 'boolean',
          defaultValue: false,
          description: 'Whether directive is scheduled for later activation'
        },
        scheduleTime: {
          type: 'timestamp',
          nullable: true,
          description: 'When to activate scheduled directive',
          index: true
        },
        expiryTime: {
          type: 'timestamp',
          nullable: true,
          description: 'When directive should expire',
          index: true
        },
        createdBy: {
          type: 'integer',
          nullable: false,
          description: 'User ID who created the directive'
        },
        createdAt: {
          type: 'timestamp',
          defaultValue: 'CURRENT_TIMESTAMP',
          description: 'Record creation timestamp'
        },
        updatedAt: {
          type: 'timestamp',
          defaultValue: 'CURRENT_TIMESTAMP',
          onUpdate: 'CURRENT_TIMESTAMP',
          description: 'Record last update timestamp'
        }
      },
      indices: [
        {
          name: 'ai_directives_active_type_idx',
          columns: ['isActive', 'type', 'priority'],
          description: 'Index for finding active directives by type and priority'
        },
        {
          name: 'ai_directives_schedule_idx',
          columns: ['scheduled', 'scheduleTime'],
          description: 'Index for scheduled directives'
        }
      ]
    };

AI Interaction Patterns

    AI Prompt Templates:
    JavaScript

// Comprehensive prompt templates for different AI interactions
const AI_PROMPT_TEMPLATES = {
  // System instructions for different contexts
  SYSTEM_INSTRUCTIONS: {
    DEFAULT: `You are a CRM assistant for MarFaNet company. Your role is to help process employee reports, generate tasks, and provide guidance on customer relationship management. Respond in Persian (Farsi) language using formal business tone.`,
    
    REPORT_PROCESSING: `You are a CRM assistant analyzing employee reports. Extract key information from the report, identify action items, and determine if any follow-up is needed. Focus on customer-related issues, representative interactions, and sales opportunities. Respond in Persian (Farsi) language.`,
    
    TASK_GENERATION: `You are a CRM assistant generating tasks based on sales data and employee reports. Create specific, actionable tasks with clear deadlines and priorities. Tasks should focus on improving representative performance, addressing inactive representatives, and capitalizing on sales opportunities. Respond in Persian (Farsi) language.`,
    
    PERFORMANCE_EVALUATION: `You are a CRM assistant evaluating employee performance based on their reports and task completion. Identify strengths, areas for improvement, and provide specific recommendations. Be constructive and focus on professional development. Respond in Persian (Farsi) language.`
  },
  
  // Templates for processing different report types
  REPORT_ANALYSIS: {
    DAILY_REPORT: `
    # Daily Report Analysis
    
    Report from: {employeeName}
    Date: {date}
    
    ## Report Content
    {reportContent}
    
    ## Analysis Instructions
    1. Summarize the key activities reported
    2. Identify any customer interactions mentioned
    3. Extract any representative names mentioned
    4. Note any issues or concerns raised
    5. Determine if any follow-up actions are needed
    
    Provide your analysis in Persian language.
    `,
    
    TECHNICAL_REPORT: `
    # Technical Report Analysis
    
    Report from: {employeeName}
    Date: {date}
    Issue: {issue}
    Status: {status}
    
    ## Report Content
    {reportContent}
    
    ## Analysis Instructions
    1. Assess the technical issue described
    2. Determine if this impacts any representatives
    3. Evaluate if the reported status seems appropriate
    4. Identify if this requires escalation
    5. Suggest any follow-up actions needed
    
    Provide your analysis in Persian language.
    `,
    
    LEAVE_REQUEST: `
    # Leave Request Analysis
    
    Request from: {employeeName}
    Date requested: {requestedDate}
    Duration: {duration}
    Reason: {reason}
    
    ## Current Team Status
    Active team members: {activeCount}
    Others on leave during this period: {othersOnLeave}
    
    ## Analysis Instructions
    1. Assess the impact of this leave on team operations
    2. Check if the timing conflicts with any critical business events
    3. Consider if task redistribution is needed
    4. Recommend approval or suggest alternatives
    
    Provide your analysis in Persian language.
    `
  },
  
  // Templates for generating tasks based on data
  TASK_GENERATION: {
    INACTIVE_REPRESENTATIVES: `
    # Task Generation: Inactive Representatives
    
    ## Representative Data
    {representativeData}
    
    ## Business Context
    - Last contact attempt: {lastContactDate}
    - Previous sales history: {salesHistory}
    - Region: {region}
    - Products: {products}
    
    ## Task Instructions
    Generate appropriate follow-up tasks for CRM team members to contact these inactive representatives. Include:
    1. Task title
    2. Detailed description with context
    3. Suggested priority (high/medium/low)
    4. Recommended deadline
    5. Suggested approach for reengagement
    
    Create one task per representative, optimized for effective reengagement.
    Provide tasks in Persian language.
    `,
    
    SALES_DECLINE: `
    # Task Generation: Sales Decline Follow-up
    
    ## Sales Data
    {salesData}
    
    ## Representative Details
    - Name: {representativeName}
    - Region: {region}
    - Previous performance: {previousPerformance}
    - Last contact: {lastContact}
    
    ## Task Instructions
    Generate appropriate follow-up tasks to address the sales decline for this representative. Include:
    1. Task title
    2. Detailed description with context and specific sales numbers
    3. Suggested priority (high/medium/low)
    4. Recommended deadline
    5. Specific questions to ask or points to address
    
    Provide tasks in Persian language.
    `,
    
    PRODUCT_PROMOTION: `
    # Task Generation: New Product Promotion
    
    ## Product Information
    {productInformation}
    
    ## Target Representatives
    {targetRepresentatives}
    
    ## Task Instructions
    Generate appropriate tasks for promoting this new product to the target representatives. Include:
    1. Task title
    2. Detailed description with product benefits and selling points
    3. Suggested priority (high/medium/low)
    4. Recommended deadline
    5. Specific promotion strategy
    
    Group representatives by region or market segment and create batched tasks where appropriate.
    Provide tasks in Persian language.
    `
  },
  
  // Templates for responding to employees
  EMPLOYEE_RESPONSES: {
    ACKNOWLEDGE_REPORT: `
    # Response to Employee Report
    
    Employee: {employeeName}
    Report type: {reportType}
    
    ## Report Content
    {reportContent}
    
    ## Response Instructions
    Generate a professional acknowledgment of the report that:
    1. Thanks the employee for their report
    2. Confirms key points understood
    3. Asks for any clarification if needed
    4. Provides guidance or feedback if appropriate
    5. Mentions next steps if any
    
    Keep the tone professional but friendly. Respond in Persian language.
    `,
    
    TASK_ASSIGNMENT: `
    # Task Assignment Response
    
    Employee: {employeeName}
    
    ## Task Details
    Title: {taskTitle}
    Description: {taskDescription}
    Priority: {taskPriority}
    Deadline: {taskDeadline}
    
    ## Response Instructions
    Generate a professional task assignment message that:
    1. Clearly communicates the task requirements
    2. Explains the importance or context
    3. Specifies the deadline clearly
    4. Provides any resources or guidance needed
    5. Asks for confirmation of understanding
    
    Keep the tone professional and clear. Respond in Persian language.
    `,
    
    PERFORMANCE_FEEDBACK: `
    # Performance Feedback Response
    
    Employee: {employeeName}
    Period: {period}
    
    ## Performance Data
    {performanceData}
    
    ## Response Instructions
    Generate constructive performance feedback that:
    1. Highlights specific strengths demonstrated
    2. Identifies areas for improvement tactfully
    3. Provides specific, actionable suggestions
    4. Encourages continued good performance
    5. Offers support for development
    
    Keep the tone constructive and supportive. Respond in Persian language.
    `
  }
};

AI Assistant Implementation:
JavaScript

    class AIAssistantService {
      constructor(settings = null) {
        this.settings = settings;
        this.promptTemplates = AI_PROMPT_TEMPLATES;
      }
      
      // Load settings from database if not provided in constructor
      async loadSettings() {
        if (!this.settings) {
          // Fetch settings from database
          // This is a placeholder - implement according to your database access pattern
          this.settings = await db.query.aiSettings.findFirst();
        }
        return this.settings;
      }
      
      // Create a secure API client for Grok
      async createApiClient() {
        const settings = await this.loadSettings();
        
        return {
          async callApi(endpoint, payload) {
            try {
              const response = await fetch(`${settings.grokApiEndpoint}/${endpoint}`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${settings.grokApiKey}`
                },
                body: JSON.stringify(payload)
              });
              
              if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API Error (${response.status}): ${JSON.stringify(errorData)}`);
              }
              
              return await response.json();
            } catch (error) {
              console.error('AI API request failed:', error);
              throw new Error(`Failed to call AI API: ${error.message}`);
            }
          }
        };
      }
      
      // Fill template with data
      fillTemplate(template, data) {
        let filledTemplate = template;
        for (const [key, value] of Object.entries(data)) {
          filledTemplate = filledTemplate.replace(new RegExp(`{${key}}`, 'g'), value);
        }
        return filledTemplate;
      }
      
      // Get active directives of a specific type
      async getActiveDirectives(type) {
        // Fetch active directives from database
        // This is a placeholder - implement according to your database access pattern
        const directives = await db.query.aiDirectives.findMany({
          where: {
            type,
            isActive: true,
            AND: [
              { OR: [
                { scheduled: false },
                { AND: [
                  { scheduled: true },
                  { scheduleTime: { lte: new Date() } }
                ]}
              ]},
              { OR: [
                { expiryTime: null },
                { expiryTime: { gt: new Date() } }
              ]}
            ]
          },
          orderBy: {
            priority: 'asc'
          }
        });
        
        return directives;
      }
      
      // Construct system prompt with directives
      async constructSystemPrompt(context, additionalContext = {}) {
        // Get base system instruction
        const baseInstruction = this.promptTemplates.SYSTEM_INSTRUCTIONS[context] || 
                               this.promptTemplates.SYSTEM_INSTRUCTIONS.DEFAULT;
        
        // Get active directives for this context
        const directives = await this.getActiveDirectives(context.toLowerCase());
        
        // Combine base instruction with directives
        let systemPrompt = baseInstruction;
        
        if (directives.length > 0) {
          systemPrompt += "\n\n# SPECIFIC DIRECTIVES\n\n";
          directives.forEach((directive, index) => {
            systemPrompt += `## Directive ${index + 1}: ${directive.title}\n${directive.content}\n\n`;
          });
        }
        
        // Add any additional context
        if (Object.keys(additionalContext).length > 0) {
          systemPrompt += "\n\n# ADDITIONAL CONTEXT\n\n";
          for (const [key, value] of Object.entries(additionalContext)) {
            systemPrompt += `## ${key}\n${value}\n\n`;
          }
        }
        
        return systemPrompt;
      }
      
      // Process an employee report
      async processEmployeeReport(reportData) {
        try {
          const apiClient = await this.createApiClient();
          const settings = await this.loadSettings();
          
          // Determine report type and select appropriate template
          const reportType = reportData.type.toUpperCase();
          const templateKey = reportType.includes('DAILY') ? 'DAILY_REPORT' : 
                             reportType.includes('TECHNICAL') ? 'TECHNICAL_REPORT' :
                             reportType.includes('LEAVE') ? 'LEAVE_REQUEST' : 'DAILY_REPORT';
          
          // Fill the template with report data
          const filledTemplate = this.fillTemplate(
            this.promptTemplates.REPORT_ANALYSIS[templateKey],
            {
              employeeName: reportData.employeeName,
              date: new Date(reportData.timestamp * 1000).toISOString().split('T')[0],
              reportContent: reportData.content,
              // Add other fields based on report type
              ...(reportData.issue ? { issue: reportData.issue } : {}),
              ...(reportData.status ? { status: reportData.status } : {}),
              ...(reportData.date ? { requestedDate: reportData.date } : {}),
              ...(reportData.duration ? { duration: reportData.duration } : {}),
              ...(reportData.reason ? { reason: reportData.reason } : {})
            }
          );
          
          // Construct system prompt with directives
          const systemPrompt = await this.constructSystemPrompt('REPORT_PROCESSING');
          
          // Call the AI API
          const response = await apiClient.callApi('chat/completions', {
            model: 'grok-1',
            messages: [
              {
                role: 'system',
                content: systemPrompt
              },
              {
                role: 'user',
                content: filledTemplate
              }
            ],
            temperature: settings.aiTemperature,
            max_tokens: settings.aiMaxTokens
          });
          
          // Process the response
          const analysisResult = response.choices[0].message.content;
          
          // Generate employee response
          const employeeResponse = await this.generateEmployeeResponse(
            'ACKNOWLEDGE_REPORT',
            {
              employeeName: reportData.employeeName,
              reportType: reportData.type,
              reportContent: reportData.content,
              analysisResult
            }
          );
          
          // Determine if tasks should be generated
          const shouldGenerateTasks = analysisResult.toLowerCase().includes('follow-up') || 
                                     analysisResult.toLowerCase().includes('action required');
          
          // Generate tasks if needed
          const tasks = shouldGenerateTasks ? 
                       await this.extractTasksFromAnalysis(analysisResult, reportData) : 
                       [];
          
          return {
            requiresResponse: true,
            responseText: employeeResponse,
            generatesTasks: shouldGenerateTasks,
            tasks: tasks,
            analysis: analysisResult
          };
        } catch (error) {
          console.error('Error processing employee report:', error);
          return {
            requiresResponse: true,
            responseText: 'گزارش شما دریافت شد. با تشکر از همکاری شما.',
            generatesTasks: false,
            tasks: [],
            error: error.message
          };
        }
      }
      
      // Generate a response to an employee
      async generateEmployeeResponse(responseType, data) {
        try {
          const apiClient = await this.createApiClient();
          const settings = await this.loadSettings();
          
          // Fill the template with data
          const filledTemplate = this.fillTemplate(
            this.promptTemplates.EMPLOYEE_RESPONSES[responseType],
            data
          );
          
          // Construct system prompt with directives
          const systemPrompt = await this.constructSystemPrompt('RESPONSE_STYLE');
          
          // Call the AI API
          const response = await apiClient.callApi('chat/completions', {
            model: 'grok-1',
            messages: [
              {
                role: 'system',
                content: systemPrompt
              },
              {
                role: 'user',
                content: filledTemplate
              }
            ],
            temperature: settings.aiTemperature,
            max_tokens: settings.aiMaxTokens
          });
          
          // Return the generated response
          return response.choices[0].message.content;
        } catch (error) {
          console.error('Error generating employee response:', error);
          return 'گزارش شما دریافت شد. با تشکر از همکاری شما.';
        }
      }
      
      // Extract tasks from analysis result
      async extractTasksFromAnalysis(analysisResult, reportData) {
        try {
          const apiClient = await this.createApiClient();
          const settings = await this.loadSettings();
          
          // Prompt for task extraction
          const extractionPrompt = `
          # Task Extraction
          
          ## Analysis Result
          ${analysisResult}
          
          ## Extraction Instructions
          Extract specific tasks that should be created based on this analysis. For each task, provide:
          1. Task title
          2. Task description
          3. Priority (high, medium, low)
          4. Suggested deadline (relative to today)
          5. Assignee type (who should handle this task)
          
          Format each task as a JSON object. Return an array of task objects.
          Example format:
          [
            {
              "title": "Contact Representative X about sales decline",
              "description": "Representative X has shown a 15% sales decline in the last month. Contact them to discuss challenges and offer support.",
              "priority": "high",
              "deadline": "2 days",
              "assigneeType": "CRM Manager"
            }
          ]
          
          If no tasks should be created, return an empty array [].
          `;
          
          // Call the AI API
          const response = await apiClient.callApi('chat/completions', {
            model: 'grok-1',
            messages: [
              {
                role: 'system',
                content: 'You are a task extraction assistant. Extract structured tasks from analysis results in JSON format.'
              },
              {
                role: 'user',
                content: extractionPrompt
              }
            ],
            temperature: 0.2, // Lower temperature for more consistent structured output
            max_tokens: settings.aiMaxTokens
          });
          
          // Parse the response
          const responseText = response.choices[0].message.content;
          
          // Extract JSON array from response (handling potential text around the JSON)
          const jsonMatch = responseText.match(/\[[\s\S]*\]/);
          if (!jsonMatch) return [];
          
          try {
            const tasks = JSON.parse(jsonMatch[0]);
            
            // Enhance tasks with metadata
            return tasks.map(task => ({
              ...task,
              sourceType: 'report_analysis',
              sourceId: reportData.messageId,
              employeeId: reportData.employeeId,
              employeeName: reportData.employeeName,
              createdAt: new Date().toISOString()
            }));
          } catch (jsonError) {
            console.error('Error parsing tasks JSON:', jsonError);
            return [];
          }
        } catch (error) {
          console.error('Error extracting tasks:', error);
          return [];
        }
      }
      
      // Generate tasks based on sales data
      async generateTasksFromSalesData(salesData, taskType) {
        try {
          const apiClient = await this.createApiClient();
          const settings = await this.loadSettings();
          
          // Select appropriate template based on task type
          const templateKey = taskType.toUpperCase();
          
          // Fill the template with sales data
          const filledTemplate = this.fillTemplate(
            this.promptTemplates.TASK_GENERATION[templateKey],
            salesData
          );
          
          // Construct system prompt with directives
          const systemPrompt = await this.constructSystemPrompt('TASK_GENERATION');
          
          // Call the AI API
          const response = await apiClient.callApi('chat/completions', {
            model: 'grok-1',
            messages: [
              {
                role: 'system',
                content: systemPrompt
              },
              {
                role: 'user',
                content: filledTemplate
              }
            ],
            temperature: settings.aiTemperature,
            max_tokens: settings.aiMaxTokens
          });
          
          // Process the response to extract structured tasks
          const generatedContent = response.choices[0].message.content;
          
          // Extract tasks using a second API call for consistent formatting
          return this.extractTasksFromAnalysis(generatedContent, { 
            messageId: 'sales_data_analysis',
            employeeId: 'system',
            employeeName: 'System'
          });
        } catch (error) {
          console.error('Error generating tasks from sales data:', error);
          return [];
        }
      }
    }

UI Component Interactions

    State Management for CRM Assistant Dashboard:
    JavaScript

// This represents the React component with detailed state management

import { useState, useEffect, useCallback, useMemo } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// UI Component with complete state management
function CrmAssistantDashboard() {
  // Active tab state
  const [activeTab, setActiveTab] = useState('activity');
  
  // Activity feed state
  const [activityFilters, setActivityFilters] = useState({
    type: 'all',
    employeeId: null,
    dateRange: { from: null, to: null },
    processed: null,
    searchQuery: ''
  });
  
  // Pagination state for activities
  const [activityPage, setActivityPage] = useState(1);
  const [activityPageSize, setActivityPageSize] = useState(20);
  
  // Task management state
  const [taskFilters, setTaskFilters] = useState({
    status: 'all',
    priority: 'all',
    assignedTo: null,
    dateRange: { from: null, to: null },
    searchQuery: ''
  });
  
  // Pagination state for tasks
  const [taskPage, setTaskPage] = useState(1);
  const [taskPageSize, setTaskPageSize] = useState(20);
  
  // AI Directive state
  const [newDirective, setNewDirective] = useState({
    type: 'general',
    title: '',
    content: '',
    priority: 10,
    isScheduled: false,
    scheduleTime: null,
    expiryTime: null
  });
  
  // Performance metrics state
  const [performanceMetrics, setPerformanceMetrics] = useState({
    employeeId: null,
    period: 'week', // week, month, quarter
    category: 'tasks' // tasks, reports, response_time
  });
  
  // Representative analytics state
  const [analyticsFilters, setAnalyticsFilters] = useState({
    region: 'all',
    status: 'all',
    salesRange: { min: null, max:
