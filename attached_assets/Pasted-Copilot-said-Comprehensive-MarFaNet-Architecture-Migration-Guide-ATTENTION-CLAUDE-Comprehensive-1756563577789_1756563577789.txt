Copilot said: # Comprehensive MarFaNet Architecture Migration Guide **ATTENTION CLAUDE
Comprehensive MarFaNet Architecture Migration Guide

ATTENTION CLAUDE SONNET 4:

This enhanced implementation guide provides atomic details for restructuring the MarFaNet application, incorporating complete specifications for all components without relying on specific file paths.
1. CRM Panel Safe Removal Strategy
Component Identification & Removal Process

    Identify CRM Panel Components:
    Code

IDENTIFY all UI routes containing:
  - Representative management interfaces
  - CRM task dashboards
  - CRM reporting screens
  - Customer interaction logs
  - CRM-specific settings pages

Navigation System Modification:
Code

LOCATE MainNavigation component 
REMOVE all navigation items with:
  - href starting with '/crm'
  - roles containing 'crm_user', 'crm_manager', 'crm_admin'
  
LOCATE Breadcrumb component
FILTER OUT any paths containing CRM segments

Database Access Layer Cleanup:
Code

PRESERVE entities:
  - Representatives
  - Customers 
  - Invoices
  - Payments
  - Products

REMOVE entities:
  - CrmTasks
  - CrmNotes
  - CrmFollowups
  - CrmActivityLogs
  - CrmSettings

UPDATE service classes:
  - Ensure Representative service retains methods needed by Admin panel
  - Remove CRM-specific methods from shared services

Permission System Update:
Code

MAINTAIN permissions:
  - 'admin.representatives.view'
  - 'admin.representatives.edit'
  - 'admin.invoices.view'
  - 'admin.invoices.create'

REMOVE permissions:
  - All permissions starting with 'crm.'
  - Role definitions for 'CRM_USER', 'CRM_MANAGER'

API Endpoint Cleanup:
Code

IDENTIFY and REMOVE endpoints:
  - API routes serving only CRM panel
  - Webhook handlers for CRM notifications
  - CRM reporting endpoints

MODIFY shared endpoints:
  - Update to only accept admin-authorized requests
  - Remove CRM-specific parameters and responses

Component Removal Verification:
Code

    IMPLEMENT verification checks:
      - Load Admin panel dashboard
      - Test representative management
      - Verify invoice creation and viewing
      - Check payment processing

2. Enhanced Telegram Bot Architecture
Existing Functionality Preservation

    Current Invoice Notification System:
    Code

PRESERVE invoice notification flow:
  TriggerEvent('invoice.created') →
  InvoiceService.sendNotification() →
  TelegramService.sendInvoiceMessage() →
  store notification status in database

ENSURE message template format maintained:
  - Invoice number
  - Customer details
  - Products list
  - Total amount
  - Payment status

Authentication & Configuration Preservation:
Code

    PRESERVE configuration data:
      - Telegram Bot Token
      - Chat ID mappings for representatives
      - Message templates
      - Notification preferences

Enhanced Bot Message Parser Implementation

    Message Type Detection System:
    Code

IMPLEMENT detectors for each message type:

// Leave request detector
function detectLeaveRequest(message) {
  return (
    message.text.includes('مرخصی') ||
    message.text.includes('درخواست مرخصی') ||
    message.from_group_title === 'بخش مرخصی'
  );
}

// Technical report detector
function detectTechnicalReport(message) {
  return (
    message.text.includes('گزارش فنی') ||
    message.text.includes('#فنی') ||
    message.from_group_title === 'گزارش فنی'
  );
}

// Daily report detector
function detectDailyReport(message) {
  return (
    message.text.includes('گزارش کار روزانه') ||
    message.text.includes('#گزارش_روزانه') ||
    message.from_group_title === 'گزارش کار روزانه'
  );
}

// Responsibility report detector
function detectResponsibilityReport(message) {
  return (
    message.text.includes('مسئولیت') ||
    message.from_group_title === 'مسئولیت ها'
  );
}

Structured Data Extraction:
Code

// Leave request parser
function parseLeaveRequest(message) {
  const datePattern = /تاریخ[:\s]+([\d\/]+)/;
  const durationPattern = /مدت[:\s]+([\d]+)(?:\s*روز)?/;
  const reasonPattern = /(?:دلیل|علت)[:\s]+(.+)(?:\n|$)/;
  
  return {
    type: 'leave_request',
    employeeName: message.from.first_name + ' ' + message.from.last_name,
    employeeId: message.from.id,
    date: (message.text.match(datePattern) || [])[1],
    duration: parseInt((message.text.match(durationPattern) || [])[1] || '1'),
    reason: (message.text.match(reasonPattern) || [])[1] || '',
    rawMessage: message.text,
    timestamp: message.date
  };
}

// Daily report parser
function parseDailyReport(message) {
  const tasksPattern = /(?:وظایف انجام شده|کارهای انجام شده)[:\s]+(.+?)(?:\n|$)/s;
  const representativesPattern = /(?:نمایندگان|نماینده)[:\s]+(.+?)(?:\n|$)/s;
  const followupPattern = /(?:پیگیری|موارد پیگیری)[:\s]+(.+?)(?:\n|$)/s;
  
  return {
    type: 'daily_report',
    employeeName: message.from.first_name + ' ' + message.from.last_name,
    employeeId: message.from.id,
    tasks: (message.text.match(tasksPattern) || [])[1] || '',
    representatives: (message.text.match(representativesPattern) || [])[1] || '',
    followup: (message.text.match(followupPattern) || [])[1] || '',
    rawMessage: message.text,
    timestamp: message.date
  };
}

Command Recognition System:
Code

    const COMMAND_PREFIXES = {
      REPORT: ['#گزارش', '#report', '/report'],
      TASK: ['#وظیفه', '#task', '/task'],
      LEAVE: ['#مرخصی', '#leave', '/leave'],
      FOLLOW_UP: ['#پیگیری', '#followup', '/followup'],
      HELP: ['#راهنما', '#help', '/help']
    };

    function extractCommand(message) {
      const text = message.text || '';
      const firstLine = text.split('\n')[0].trim();
      const words = firstLine.split(' ');
      
      for (const [type, prefixes] of Object.entries(COMMAND_PREFIXES)) {
        for (const prefix of prefixes) {
          if (words[0] === prefix) {
            return {
              type,
              args: words.slice(1),
              fullCommand: firstLine,
              restOfMessage: text.substring(firstLine.length).trim()
            };
          }
        }
      }
      
      return null;
    }

Complete Telegram Bot Command Taxonomy

    Command Structure Definition:
    Code

const COMMAND_STRUCTURE = {
  REPORT: {
    format: "#گزارش {نوع گزارش} {توضیحات}",
    types: ['روزانه', 'هفتگی', 'فنی', 'فروش'],
    examples: ["#گزارش روزانه پیگیری 10 نماینده و رفع مشکلات فنی"],
    handler: handleReportCommand
  },
  
  TASK: {
    format: "#وظیفه {اولویت} {توضیحات}",
    priorities: ['عادی', 'مهم', 'فوری'],
    examples: ["#وظیفه مهم پیگیری نماینده کرمان برای فاکتور معوق"],
    handler: handleTaskCommand
  },
  
  LEAVE: {
    format: "#مرخصی {تاریخ} {مدت} {دلیل}",
    examples: ["#مرخصی 1402/08/15 2 مراجعه به پزشک"],
    handler: handleLeaveCommand
  },
  
  FOLLOW_UP: {
    format: "#پیگیری {شناسه نماینده} {توضیحات}",
    examples: ["#پیگیری R1024 عدم پرداخت فاکتور شماره 15432"],
    handler: handleFollowUpCommand
  },
  
  HELP: {
    format: "#راهنما {دستور اختیاری}",
    examples: ["#راهنما", "#راهنما گزارش"],
    handler: handleHelpCommand
  }
};

Response Format Templates:
Code

    const RESPONSE_TEMPLATES = {
      REPORT_RECEIVED: `✅ گزارش {reportType} شما دریافت شد.

تاریخ ثبت: {date} شناسه گزارش: {reportId}

این گزارش توسط دستیار هوش مصنوعی بررسی خواهد شد.`,
Code

 TASK_CREATED: `⚠️ وظیفه جدید ایجاد شد

شناسه: {taskId} اولویت: {priority} توضیحات: {description} مهلت انجام: {dueDate}

لطفا نتیجه پیگیری را با دستور #بروزرسانی {taskId} گزارش کنید.`,
Code

 LEAVE_REQUEST_RECEIVED: `📝 درخواست مرخصی شما ثبت شد

تاریخ: {date} مدت: {duration} روز دلیل: {reason} وضعیت: در انتظار بررسی

نتیجه بررسی به شما اطلاع داده خواهد شد.`,
Code

 FOLLOW_UP_CREATED: `🔍 پیگیری جدید برای نماینده {representativeId} ثبت شد

شناسه پیگیری: {followUpId} توضیحات: {description}

لطفا نتیجه را با دستور #بروزرسانی {followUpId} گزارش کنید.`,
Code

 ERROR_INVALID_FORMAT: `❌ فرمت دستور نامعتبر است

دستور صحیح: {correctFormat}

مثال: {example}

برای راهنمایی بیشتر، دستور #راهنما را وارد کنید.` };
Code


## 3. Database Schema Detailed Design

### AI Settings Entity

Table: ai_settings

Columns:

    id: INTEGER PRIMARY KEY AUTOINCREMENT

    grok_api_key: VARCHAR(255) NOT NULL Description: API key for Grok AI service Constraints: Encrypted at rest

    grok_api_endpoint: VARCHAR(255) NOT NULL DEFAULT 'https://api.grok.x.ai/v1' Description: Endpoint URL for Grok API

    ai_temperature: FLOAT NOT NULL DEFAULT 0.7 Description: Controls randomness of AI responses Constraints: Range 0.0-1.0

    ai_max_tokens: INTEGER NOT NULL DEFAULT 4096 Description: Maximum token length for responses

    created_at: TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP

    updated_at: TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP

Indexes:

    PRIMARY KEY (id)

Notes:

    Only one row should exist in this table (singleton)
    API key should be encrypted when stored

Code


### Telegram Activities Entity

Table: telegram_activities

Columns:

    id: INTEGER PRIMARY KEY AUTOINCREMENT

    message_id: VARCHAR(50) NOT NULL Description: Telegram message ID Constraints: UNIQUE

    chat_id: VARCHAR(50) NOT NULL Description: Telegram chat/group ID

    group_name: VARCHAR(100) NOT NULL Description: Human-readable group name

    user_id: VARCHAR(50) NOT NULL Description: Telegram user ID of sender

    user_name: VARCHAR(100) NOT NULL Description: Full name of sender

    message_type: VARCHAR(20) NOT NULL Description: Type of message (report, request, task, etc.) Constraints: One of predefined types

    content: TEXT NOT NULL Description: Full message text

    parsed_data: JSON Description: Structured data extracted from message

    processed: BOOLEAN NOT NULL DEFAULT FALSE Description: Whether message has been processed

    ai_processed: BOOLEAN NOT NULL DEFAULT FALSE Description: Whether AI has processed this message

    ai_response_id: VARCHAR(50) Description: ID of AI response message if sent

    created_at: TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP

Indexes:

    PRIMARY KEY (id)
    UNIQUE INDEX (message_id)
    INDEX (user_id)
    INDEX (message_type)
    INDEX (processed)
    INDEX (created_at)

Foreign Keys:

    ai_response_id -> telegram_activities(message_id) ON DELETE SET NULL

Code


### CRM Employee Entity

Table: crm_employees

Columns:

    id: INTEGER PRIMARY KEY AUTOINCREMENT

    name: VARCHAR(100) NOT NULL Description: Employee full name

    telegram_username: VARCHAR(50) Description: Telegram username (without @) Constraints: UNIQUE if not NULL

    telegram_id: VARCHAR(50) NOT NULL Description: Telegram user ID Constraints: UNIQUE

    position: VARCHAR(50) Description: Job position/title

    is_active: BOOLEAN NOT NULL DEFAULT TRUE Description: Whether employee is currently active

    permission_level: INTEGER NOT NULL DEFAULT 1 Description: Permission level (1=regular, 2=supervisor, 3=manager)

    created_at: TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP

    updated_at: TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP

Indexes:

    PRIMARY KEY (id)
    UNIQUE INDEX (telegram_id)
    UNIQUE INDEX (telegram_username) WHERE telegram_username IS NOT NULL
    INDEX (is_active)

Code


### CRM Tasks Entity

Table: crm_tasks

Columns:

    id: INTEGER PRIMARY KEY AUTOINCREMENT

    title: VARCHAR(200) NOT NULL Description: Task title/summary

    description: TEXT NOT NULL Description: Detailed task description

    assigned_to_id: INTEGER NOT NULL Description: Employee ID task is assigned to

    representative_id: INTEGER Description: Representative ID if task is related to a representative

    status: VARCHAR(20) NOT NULL DEFAULT 'pending' Description: Task status Constraints: One of ('pending', 'in_progress', 'completed', 'cancelled')

    priority: VARCHAR(20) NOT NULL DEFAULT 'medium' Description: Task priority Constraints: One of ('low', 'medium', 'high', 'urgent')

    source: VARCHAR(20) NOT NULL DEFAULT 'manual' Description: Source of task creation Constraints: One of ('manual', 'ai_generated', 'telegram', 'system')

    due_date: TIMESTAMP Description: When task should be completed

    completed_at: TIMESTAMP Description: When task was marked complete

    created_at: TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP

    updated_at: TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP

Indexes:

    PRIMARY KEY (id)
    INDEX (assigned_to_id)
    INDEX (representative_id)
    INDEX (status)
    INDEX (priority)
    INDEX (due_date)

Foreign Keys:

    assigned_to_id -> crm_employees(id) ON DELETE CASCADE
    representative_id -> representatives(id) ON DELETE SET NULL

Code


### AI Directives Entity

Table: ai_directives

Columns:

    id: INTEGER PRIMARY KEY AUTOINCREMENT

    title: VARCHAR(100) NOT NULL Description: Short directive title

    content: TEXT NOT NULL Description: Full directive text

    directive_type: VARCHAR(30) NOT NULL Description: Type of directive Constraints: One of ('general', 'task_generation', 'response_style', 'follow_up', 'performance_evaluation')

    is_active: BOOLEAN NOT NULL DEFAULT TRUE Description: Whether directive is currently active

    scheduled: BOOLEAN NOT NULL DEFAULT FALSE Description: Whether directive is scheduled for future

    schedule_time: TIMESTAMP Description: When directive should become active

    expiry_time: TIMESTAMP Description: When directive should expire

    priority: INTEGER NOT NULL DEFAULT 10 Description: Directive priority (higher number = higher priority)

    created_by: INTEGER NOT NULL Description: Admin user ID who created directive

    created_at: TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP

    updated_at: TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP

Indexes:

    PRIMARY KEY (id)
    INDEX (directive_type)
    INDEX (is_active)
    INDEX (schedule_time)
    INDEX (priority)

Foreign Keys:

    created_by -> users(id) ON DELETE CASCADE

Code


## 4. AI Interaction Patterns

### Prompt Templates for Different CRM Scenarios

1. **Daily Report Processing**:

System: You are a CRM assistant for MarFaNet, helping process daily reports from employees. Extract key information, identify action items, and generate appropriate responses. Your responses should be professional and in Persian.

User: Process this employee daily report:

Employee: {employeeName} Group: گزارش کار روزانه Date: {reportDate} Message: {fullMessage}

Extract the following information:

    Representatives contacted
    Issues identified
    Actions taken
    Required follow-ups

Then determine if any new tasks should be created for this employee or others.
Code


2. **Technical Issue Assessment**:

System: You are a CRM assistant for MarFaNet specialized in assessing technical reports. Analyze the report, categorize issues, and suggest solutions based on common problems. Your responses should be professional and in Persian.

User: Process this technical report:

Employee: {employeeName} Group: گزارش فنی Representative: {representativeInfo} Issue: {issueDescription}

Please:

    Categorize the technical issue (installation problem, software bug, user error, etc.)
    Assess severity (low, medium, high, critical)
    Suggest troubleshooting steps
    Determine if this requires escalation to technical team

Code


3. **Representative Performance Analysis**:

System: You are a CRM assistant for MarFaNet analyzing representative performance. Review the data and provide insights. Your responses should be professional and in Persian.

User: Analyze this representative performance data:

Representative: {representativeName} ({representativeId}) Region: {region} Current Period Sales: {currentSales} Previous Period Sales: {previousSales} Sales Change: {salesChangePercentage}% Average Order Value: {averageOrderValue} Last Contact: {lastContactDate}

Please provide:

    Performance assessment (improving, declining, stable)
    Potential reasons for current trend
    Recommended follow-up actions
    Priority level for intervention (low, medium, high)

Code


### Response Processing & Handling Strategy

1. **AI Response Validation Flow**:

function validateAndProcessAiResponse(response, context) { // Check for response structure if (!response || typeof response !== 'object') { return createErrorResponse('Invalid response structure'); }
Code

 // Validate required fields based on request type
 if (context.requestType === 'dailyReport') {
   if (!response.analysis || !response.recommendations) {
     return createErrorResponse('Incomplete report analysis');
   }
   
   // Check for suggested tasks
   if (response.tasks && Array.isArray(response.tasks)) {
     // Validate each task has required fields
     const validTasks = response.tasks.filter(task => 
       task.title && task.priority && task.assignedTo);
     
     response.tasks = validTasks;
   }
 }
 
 // Sanitize response text
 if (response.messageToEmployee) {
   response.messageToEmployee = sanitizeText(response.messageToEmployee);
 }
 
 // Add metadata
 response.processedAt = new Date().toISOString();
 response.contextId = context.id;
 
 return response;

}
Code


2. **Response Execution Strategy**:

async function executeAiResponseActions(validatedResponse, context) { const actions = [];
Code

 // Send message to employee if needed
 if (validatedResponse.messageToEmployee) {
   actions.push(
     telegramService.sendMessage(
       context.chatId, 
       validatedResponse.messageToEmployee, 
       { reply_to_message_id: context.messageId }
     )
   );
 }
 
 // Create tasks if recommended
 if (validatedResponse.tasks && validatedResponse.tasks.length > 0) {
   for (const task of validatedResponse.tasks) {
     actions.push(
       taskService.createTask({
         title: task.title,
         description: task.description || task.title,
         assignedToId: findEmployeeIdByName(task.assignedTo),
         priority: task.priority,
         dueDate: task.dueDate || calculateDefaultDueDate(task.priority),
         source: 'ai_generated',
         relatedMessageId: context.messageId
       })
     );
   }
 }
 
 // Record analysis for reporting
 actions.push(
   analyticsService.recordAnalysis(
     context.messageId,
     validatedResponse.analysis,
     context.employeeId
   )
 );
 
 // Execute all actions concurrently
 return Promise.all(actions);

}
Code


## 5. UI Component Interactions & State Management

### Activity Feed Component State Flow

// Initial state const [activities, setActivities] = useState([]); const [isLoading, setIsLoading] = useState(true); const [error, setError] = useState(null); const [page, setPage] = useState(1); const [hasMore, setHasMore] = useState(true); const [filters, setFilters] = useState({ type: null, employeeId: null, dateRange: { start: null, end: null }, processed: null });

// Data fetching with filters and pagination const fetchActivities = useCallback(async () => { setIsLoading(true); setError(null);

try { const queryParams = new URLSearchParams(); queryParams.append('page', page); queryParams.append('limit', 20);
Code

if (filters.type) queryParams.append('type', filters.type);
if (filters.employeeId) queryParams.append('employeeId', filters.employeeId);
if (filters.processed !== null) queryParams.append('processed', filters.processed);

if (filters.dateRange.start) {
  queryParams.append('startDate', formatDate(filters.dateRange.start));
}

if (filters.dateRange.end) {
  queryParams.append('endDate', formatDate(filters.dateRange.end));
}

const response = await fetch(`/api/admin/crm-assistant/activities?${queryParams.toString()}`);

if (!response.ok) {
  throw new Error(`Error ${response.status}: ${await response.text()}`);
}

const data = await response.json();

setActivities(prev => page === 1 ? data.activities : [...prev, ...data.activities]);
setHasMore(data.hasMore);

} catch (err) { setError(err.message); console.error('Failed to fetch activities:', err); } finally { setIsLoading(false); } }, [page, filters]);

// Effect for initial load and refreshes useEffect(() => { fetchActivities();

// Set up periodic refresh const refreshInterval = setInterval(() => { if (page === 1) { // Only auto-refresh the first page fetchActivities(); } }, 30000); // 30 seconds

return () => clearInterval(refreshInterval); }, [fetchActivities, page]);

// Filter change handler const handleFilterChange = (newFilters) => { setFilters(prev => ({ ...prev, ...newFilters })); setPage(1); // Reset to first page when filters change };

// Load more handler const handleLoadMore = () => { setPage(prev => prev + 1); };
Code


### AI Directive Panel State Management

// Initial state const [directive, setDirective] = useState({ title: '', content: '', type: 'general', scheduled: false, scheduleTime: '', priority: 10, expiryTime: '' });

const [validationErrors, setValidationErrors] = useState({}); const [isSaving, setIsSaving] = useState(false); const [saveSuccess, setSaveSuccess] = useState(false);

// Form change handler const handleChange = (field, value) => { setDirective(prev => ({ ...prev, [field]: value }));

// Clear validation error when field is changed if (validationErrors[field]) { setValidationErrors(prev => { const newErrors = { ...prev }; delete newErrors[field]; return newErrors; }); }

// Reset success message if (saveSuccess) { setSaveSuccess(false); } };

// Validation function const validateDirective = () => { const errors = {};

if (!directive.title.trim()) { errors.title = 'عنوان دستورالعمل الزامی است'; } else if (directive.title.length > 100) { errors.title = 'عنوان نباید بیشتر از 100 حرف باشد'; }

if (!directive.content.trim()) { errors.content = 'محتوای دستورالعمل الزامی است'; }

if (directive.scheduled && !directive.scheduleTime) { errors.scheduleTime = 'زمان اجرا برای دستورالعمل‌های زمانبندی شده الزامی است'; }

if (directive.priority < 1 || directive.priority > 100) { errors.priority = 'اولویت باید بین 1 تا 100 باشد'; }

return errors; };

// Form submission const handleSubmit = async (e) => { e.preventDefault();

const errors = validateDirective(); if (Object.keys(errors).length > 0) { setValidationErrors(errors); return; }

setIsSaving(true);

try { const response = await fetch('/api/admin/crm-assistant/directives', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(directive) });
Code

if (!response.ok) {
  throw new Error(`Error ${response.status}: ${await response.text()}`);
}

// Reset form on success
setDirective({
  title: '',
  content: '',
  type: 'general',
  scheduled: false,
  scheduleTime: '',
  priority: 10,
  expiryTime: ''
});

setSaveSuccess(true);

// Trigger refetch of directives list
refetchDirectives();

} catch (err) { setValidationErrors({ submit: err.message }); console.error('Failed to save directive:', err); } finally { setIsSaving(false); } };
Code


### Tasks Overview Component with Error Handling

// Initial state setup with error states const [tasks, setTasks] = useState([]); const [isLoading, setIsLoading] = useState(true); const [error, setError] = useState(null); const [retryCount, setRetryCount] = useState(0);

// Data fetching with error handling const fetchTasks = useCallback(async () => { setIsLoading(true);

try { const response = await fetch('/api/admin/crm-assistant/tasks');
Code

if (!response.ok) {
  // Handle specific error codes
  if (response.status === 401) {
    throw new Error('غیرمجاز: لطفا مجددا وارد سیستم شوید');
  } else if (response.status === 403) {
    throw new Error('دسترسی ممنوع: شما مجوز مشاهده این اطلاعات را ندارید');
  } else {
    throw new Error(`خطای ${response.status}: مشکلی در دریافت اطلاعات رخ داده است`);
  }
}

const data = await response.json();
setTasks(data.tasks);
setError(null);

} catch (err) { setError(err.message); console.error('Failed to fetch tasks:', err); } finally { setIsLoading(false); } }, []);

// Error retry mechanism useEffect(() => { if (error && retryCount < 3) { const timer = setTimeout(() => { setRetryCount(prev => prev + 1); fetchTasks(); }, 3000 * (retryCount + 1)); // Exponential backoff
Code

return () => clearTimeout(timer);

} }, [error, retryCount, fetchTasks]);

// Initial data load useEffect(() => { fetchTasks(); }, [fetchTasks]);

// Task status update with optimistic UI const updateTaskStatus = async (taskId, newStatus) => { // Save current tasks for rollback const previousTasks = [...tasks];

// Optimistic update setTasks(prev => prev.map(task => task.id === taskId ? { ...task, status: newStatus } : task ) );

try { const response = await fetch(/api/admin/crm-assistant/tasks/${taskId}/status, { method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ status: newStatus }) });
Code

if (!response.ok) {
  throw new Error(`Failed to update task status`);
}

// Task updated successfully

} catch (err) { // Rollback on error setTasks(previousTasks); console.error('Failed to update task status:', err);
Code

// Show error notification
showNotification({
  type: 'error',
  title: 'خطا در بروزرسانی وضعیت',
  message: err.message
});

} };
Code


## 6. Security Implementation Details

### API Key Encryption Strategy

// Encryption utility for API keys const crypto = require('crypto');

// Get encryption key from environment (32 bytes for AES-256) const ENCRYPTION_KEY = Buffer.from(process.env.ENCRYPTION_KEY || '', 'hex'); const IV_LENGTH = 16; // AES block size is 16 bytes

// Encrypt sensitive data function encrypt(text) { // Generate random initialization vector const iv = crypto.randomBytes(IV_LENGTH);

// Create cipher const cipher = crypto.createCipheriv( 'aes-256-cbc', ENCRYPTION_KEY, iv );

// Encrypt data let encrypted = cipher.update(text, 'utf8', 'hex'); encrypted += cipher.final('hex');

// Return IV + encrypted data as hex return iv.toString('hex') + ':' + encrypted; }

// Decrypt sensitive data function decrypt(text) { try { // Split IV from encrypted data const parts = text.split(':'); if (parts.length !== 2) { throw new Error('Invalid encrypted format'); }
Code

const iv = Buffer.from(parts[0], 'hex');
const encryptedText = parts[1];

// Create decipher
const decipher = crypto.createDecipheriv(
  'aes-256-cbc',
  ENCRYPTION_KEY,
  iv
);

// Decrypt data
let decrypted = decipher.update(encryptedText, 'hex', 'utf8');
decrypted += decipher.final('utf8');

return decrypted;

} catch (err) { console.error('Decryption failed:', err); return null; } }

// API key handling in database operations async function saveApiKey(apiKey) { const encryptedKey = encrypt(apiKey);

await db .update(aiSettings) .set({ grok_api_key: encryptedKey }) .where(eq(aiSettings.id, 1)); }

async function getApiKey() { const settings = await db.query.aiSettings.findFirst();

if (!settings?.grok_api_key) { return null; }

return decrypt(settings.grok_api_key); }
Code


### Access Control Implementation

// Permission-based access control system const PERMISSION_LEVELS = { ADMIN: ['admin.crm_assistant.view', 'admin.crm_assistant.manage', 'admin.crm_assistant.configure_ai'], MANAGER: ['admin.crm_assistant.view', 'admin.crm_assistant.manage'], VIEWER: ['admin.crm_assistant.view'] };

// Middleware for checking permissions function requirePermission(permission) { return async function(req, res, next) { const session = await getServerSession(req, res, authOptions);
Code

if (!session || !session.user) {
  return res.status(401).json({ error: 'Unauthorized: Authentication required' });
}

// Get user permissions from database
const user = await db.query.users.findFirst({
  where: eq(users.id, session.user.id),
  with: { userPermissions: true }
});

if (!user) {
  return res.status(401).json({ error: 'Unauthorized: User not found' });
}

// Check if user has required permission
const userPermissions = user.userPermissions.map(p => p.permission);

if (!userPermissions.includes(permission)) {
  return res.status(403).json({ error: 'Forbidden: Insufficient permissions' });
}

// Add user to request for downstream use
req.user = {
  id: user.id,
  name: user.name,
  permissions: userPermissions
};

next();

}; }

// API route protection example // In API route definition: export default requirePermission('admin.crm_assistant.view')(async function handler(req, res) { // Route implementation here // Can safely access req.user });

// UI component conditional rendering function CrmAssistantComponent() { const { data: session } = useSession(); const [userPermissions, setUserPermissions] = useState([]);

useEffect(() => { // Fetch user permissions when session changes if (session?.user) { fetch('/api/user/permissions') .then(res => res.json()) .then(data => setUserPermissions(data.permissions)) .catch(err => console.error('Failed to fetch permissions:', err)); } }, [session]);

// Check if user has specific permission const hasPermission = useCallback((permission) => { return userPermissions.includes(permission); }, [userPermissions]);

return ( <div> {/* View-only components */} {hasPermission('admin.crm_assistant.view') && ( <ActivityFeed /> )}
Code

  {/* Management components */}
  {hasPermission('admin.crm_assistant.manage') && (
    <TaskManagement />
  )}
  
  {/* AI configuration components */}
  {hasPermission('admin.crm_assistant.configure_ai') && (
    <AISettings />
  )}
</div>

); }
Code


### Input Validation Strategy

// Input validation utilities function validateApiKey(apiKey) { // Grok API keys follow a specific format const apiKeyRegex = /^grok-[a-zA-Z0-9]{24,}$/;

if (!apiKeyRegex.test(apiKey)) { return { valid: false, error: 'API key format is invalid' }; }

return { valid: true }; }

function sanitizeHtml(text) { // Remove potentially dangerous HTML tags and attributes return text .replace(/<script\b[^<](?:(?!</script>)<[^<])</script>/gi, '') .replace(/<iframe\b[^<](?:(?!</iframe>)<[^<])</iframe>/gi, '') .replace(/<img[^>]>/gi, '') .replace(/on\w+="[^"]"/gi, '') .replace(/javascript:/gi, ''); }

// Request validation middleware const validateRequest = (schema) => { return async (req, res, next) => { try { // Parse request body if needed const data = req.body;
Code

  // Validate against schema
  const result = schema.safeParse(data);
  
  if (!result.success) {
    // Extract validation errors
    const errors = result.error.errors.map(err => ({
      path: err.path.join('.'),
      message: err.message
    }));
    
    return res.status(400).json({ 
      error: 'Invalid request data',
      validationErrors: errors
    });
  }
  
  // Add validated data to request
  req.validatedData = result.data;
  
  next();
} catch (err) {
  console.error('Validation error:', err);
  return res.status(500).json({ error: 'Validation processing error' });
}

}; };

// Example schema for AI directive const directiveSchema = z.object({ title: z.string() .min(3, 'Title must be at least 3 characters') .max(100, 'Title must be at most 100 characters'),

content: z.string() .min(10, 'Content must be at least 10 characters'),

directive_type: z.enum(['general', 'task_generation', 'response_style', 'follow_up', 'performance_evaluation']),

is_active: z.boolean().optional().default(true),

scheduled: z.boolean().optional().default(false),

schedule_time: z.string() .datetime() .optional() .refine(val => !val || new Date(val) > new Date(), { message: 'Schedule time must be in the future' }),

priority: z.number() .int() .min(1) .max(100) .optional() .default(10) });

// Usage in API route export default [ requirePermission('admin.crm_assistant.configure_ai'), validateRequest(directiveSchema), async function handler(req, res) { // Can safely use req.validatedData const directive = req.validatedData;
Code

// Process directive...

} ];
Code


## Implementation Approach & Verification

### Step-by-Step Implementation Plan

1. **Preparation Phase**:
   - Create full database backup
   - Document all CRM panel routes and dependencies
   - Set up testing environment for validation

2. **Database Migration Phase**:
   - Create and test new schema additions
   - Add migration scripts with proper rollback capability
   - Run migrations in development environment first

3. **CRM Panel Removal Phase**:
   - Remove CRM-specific routes and components
   - Update navigation and permissions
   - Test admin panel functionality after removal

4. **Telegram Bot Enhancement Phase**:
   - Extend bot service while preserving current functionality
   - Implement message parsing and command handling
   - Test with simulated messages before deployment

5. **Admin Panel Enhancement Phase**:
   - Add CRM Assistant module to admin panel
   - Implement AI settings configuration
   - Create activity monitoring and directive interfaces

6. **Integration Testing Phase**:
   - Test complete workflow from Telegram to admin panel
   - Verify AI processing and response generation
   - Test task creation and management

7. **Deployment Phase**:
   - Schedule maintenance window
   - Deploy changes with monitoring
   - Have rollback procedure ready

### Verification Checklist

- Admin panel loads without errors after CRM removal
- Existing invoice notification functionality works unchanged
- Telegram bot successfully processes different message types
- Bot responses follow expected format and content
- CRM Assistant dashboard displays correct data
- AI directives properly influence bot behavior
- Task creation and assignment flow works end-to-end
- Security measures prevent unauthorized access
- Error handling works properly in edge cases

This comprehensive guide provides atomic implementation details for all aspects of the MarFaNet architecture migration, with specific code patterns, data structures, and workflows to enable successful implementation regardless of the exact file structure of your application.
